<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Bolero Tea Room - V3 Fixed</title>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.18/Tone.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/soundfont-player@0.12.0/dist/soundfont-player.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Roboto:wght@300;400&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg: #1a120b; --panel: #2e2018; --gold: #d4af37; --gold-dim: #8c7322;
      --cream: #f5f5dc; --text: #efebe9; --highlight: #ffecb3; --cue-color: #ff6f00;
    }
    body {
      background: var(--bg);
      background-image: radial-gradient(circle at center, #2c1e16 0%, #0d0805 100%);
      color: var(--text); font-family: 'Roboto', sans-serif;
      display: flex; flex-direction: column; align-items: center;
      padding: 15px; margin: 0; user-select: none; min-height: 100vh;
    }
    h2 {
      font-family: 'Playfair Display', serif; color: var(--gold); margin: 10px 0;
      text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 2px 4px rgba(0,0,0,0.8);
      font-size: 1.8rem; border-bottom: 1px solid var(--gold-dim); padding-bottom: 10px;
    }
    .studio-rack {
      background: var(--panel); padding: 25px; border-radius: 8px; width: 100%; max-width: 950px;
      border: 1px solid #4e342e; box-shadow: 0 15px 40px rgba(0,0,0,0.7); position: relative;
      background-image: repeating-linear-gradient(45deg, rgba(255,255,255,0.02) 0px, rgba(255,255,255,0.02) 2px, transparent 2px, transparent 4px);
    }
    .display-section {
      background: #18100c; border: 3px double var(--gold-dim); border-radius: 4px;
      padding: 15px; margin-bottom: 25px; display: flex; justify-content: space-between; align-items: center;
      box-shadow: inset 0 0 30px rgba(0,0,0,0.9);
    }
    .knob-group { display: flex; flex-direction: column; align-items: center; margin-right: 15px; }
    .knob-label { font-family: 'Playfair Display', serif; font-size: 0.8rem; color: var(--gold); margin-bottom: 5px; letter-spacing: 1px; }
    input[type=range].eq-slider { -webkit-appearance: none; width: 100px; height: 4px; background: #4e342e; border-radius: 2px; }
    input[type=range].eq-slider::-webkit-slider-thumb {
      -webkit-appearance: none; width: 16px; height: 16px; background: var(--gold); border: 2px solid #fff; border-radius: 50%; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    }
    .string-monitor {
      font-family: 'Playfair Display', serif; font-style: italic; font-size: 1.8rem; color: var(--highlight);
      text-shadow: 0 0 5px var(--gold); min-width: 150px; text-align: right;
    }
    
    /* === UI SPLIT PRESET/GUITAR + STATUS GRID === */
    .control-deck.split-deck { grid-template-columns: 1fr 1fr; gap: 12px; }
    @media (max-width: 760px) {
      .control-deck.split-deck { grid-template-columns: 1fr; }
    }
    .inline-row { display:flex; gap:10px; align-items:center; }
    .inline-row .note-select { flex:1; }
    .inline-row .btn-small { white-space:nowrap; }
    .status-grid {
      display:grid; grid-template-columns: 1fr 1fr;
      gap: 4px 14px; justify-content:end; align-items:end;
    }
    .status-value {
      font-family: 'Playfair Display', serif; font-style: italic; font-size: 1.25rem; color: var(--highlight);
      text-shadow: 0 0 4px var(--gold); text-align: right; min-width: 110px;
    }
    .status-label {
      font-size: 0.65rem; color:#8d6e63; letter-spacing: 0.06em; text-transform: uppercase; text-align:right;
    }
.string-label { font-size: 0.7rem; color: #8d6e63; text-align: right; text-transform: uppercase; letter-spacing: 2px;}
    .timeline-wrapper {
      position: relative; height: 140px; width: 100%; background: #231711;
      border: 2px solid var(--gold-dim); border-radius: 4px; display: flex; overflow: hidden; margin-bottom: 25px;
      box-shadow: inset 0 0 20px #000;
    }
    .segment {
      position: relative; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center;
      border-right: 1px solid rgba(212, 175, 55, 0.2); transition: background 0.1s;
    }
    .type-bass { background: linear-gradient(to bottom, #3e2723, #281815); color: #ffcc80; }
    .type-fill { background: linear-gradient(to bottom, #263238, #161e22); color: #b0bec5; }
    .type-chat { background: linear-gradient(to bottom, #1b5e20, #0d3311); color: #a5d6a7; }
    .segment.playing { filter: brightness(1.3); box-shadow: inset 0 0 30px var(--gold); border: 1px solid var(--gold); z-index: 2; }
    .segment.cue-point { border-top: 4px solid var(--cue-color); }
    .segment.cue-point.playing { background: var(--cue-color); color: #000; }
    .cue-icon {
      position: absolute; top: 4px; right: 4px; font-size: 0.6rem; color: var(--cue-color);
      border: 1px solid var(--cue-color); padding: 1px 3px; border-radius: 2px; background: rgba(0,0,0,0.5);
    }
    .note-select {
      background: rgba(0,0,0,0.3); border: 1px solid var(--gold-dim); color: var(--cream);
      font-size: 0.7rem; margin-top: 8px; width: 90%; border-radius: 2px; font-family: 'Roboto', sans-serif;
    }
    .control-deck {
      display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; align-items: center; margin-bottom: 20px;
      background: #241914; padding: 15px; border-radius: 6px; border: 1px solid #3e2723;
    }
    .btn-main {
      background: linear-gradient(to bottom, #d4af37, #b08d26); color: #3e2723; border: 1px solid #ffe082;
      padding: 15px; font-size: 1.1rem; font-weight: bold; border-radius: 4px; cursor: pointer; width: 100%;
      box-shadow: 0 4px 6px rgba(0,0,0,0.5); font-family: 'Playfair Display', serif; text-transform: uppercase; transition: all 0.1s;
    }
    .btn-main:active { transform: translateY(2px); box-shadow: 0 1px 2px rgba(0,0,0,0.5); }
    .btn-main.stop { background: linear-gradient(to bottom, #c62828, #8e0000); color: #fff; border-color: #ff8a80; }
    .chord-rack {
      display: flex; gap: 10px; background: #1a120b; padding: 10px; border-radius: 6px;
      border: 1px solid var(--gold-dim); justify-content: center;
    }
    .btn-chord {
      flex: 1; background: #2e2018; border: 1px solid #5d4037; color: #a1887f; padding: 12px;
      cursor: pointer; font-family: 'Playfair Display', serif; font-size: 1.1rem; font-weight: bold; transition: 0.2s;
    }
    .btn-chord.active {
      background: var(--gold); color: #2e2018; box-shadow: 0 0 15px rgba(212, 175, 55, 0.4); border-color: #fff;
    }
    .switch input { display:none; }
    .slider-toggle { background: #3e2723; border: 1px solid #5d4037; color: #888; padding: 2px 8px; border-radius: 4px; font-size: 0.8rem; }
    input:checked + .slider-toggle { color: var(--gold); border-color: var(--gold); font-weight: bold; }
    .err-msg { color: #ff5252; margin-top: 10px; font-size: 0.9rem; max-width: 80%; text-align: center; }
  
    /* === NEW UI (V√íNG H·ª¢P √ÇM + PRESET + V√ÄO B√ÄI) === */
    .details-panel { background:#241914; border:1px solid #3e2723; border-radius:6px; padding:10px 12px; margin-top:12px; }
    .details-panel > summary {
      cursor:pointer; list-style:none; font-family:'Playfair Display', serif; color:var(--gold);
      letter-spacing:1px; text-transform:uppercase; font-size:0.9rem;
    }
    .details-panel > summary::-webkit-details-marker { display:none; }
    .details-panel > summary:after { content:" ‚ñæ"; color:#8d6e63; }
    .details-panel[open] > summary:after { content:" ‚ñ¥"; }
    .btn-small {
      background:#2e2018; color:var(--gold); border:1px solid var(--gold);
      padding:6px 10px; cursor:pointer; font-weight:bold; font-size:0.75rem;
      font-family:'Playfair Display', serif; letter-spacing:1px; text-transform:uppercase;
    }
    .section-block { margin-top:14px; padding:12px; background:#241914; border-radius:6px; border:1px solid #3e2723; }
    .section-header { display:flex; justify-content:space-between; align-items:flex-start; gap:12px; }
    .section-sub { font-size:0.75rem; color:#8d6e63; margin-top:4px; line-height:1.35; }
    .prog-grid {
      display:grid; grid-template-columns: repeat(6, 1fr); gap:8px; margin-top:12px;
    }
    .prog-slot {
      position:relative;
      background:#1a120b; border:1px dashed #5d4037; border-radius:6px; min-height:44px;
      display:flex; align-items:center; justify-content:center; padding:8px 6px;
      font-family:'Playfair Display', serif; font-weight:bold; color:#a1887f;
      transition: transform 0.08s, border-color 0.12s, box-shadow 0.12s;
    }
    .prog-slot.filled { border-style:solid; color:var(--gold); }
    .prog-slot.dragover { border-color:var(--gold); box-shadow: 0 0 0 2px rgba(212,175,55,0.25) inset; }
    .prog-slot.current { box-shadow: 0 0 0 2px rgba(255,111,0,0.6) inset; border-color: var(--cue-color); }
    .slot-index {
      position:absolute; top:4px; left:6px; font-size:0.65rem; color:#8d6e63; font-weight:normal;
      font-family:'Roboto', sans-serif;
    }
    .slot-clear {
      position:absolute; top:3px; right:6px; cursor:pointer; font-size:0.8rem; color:#8d6e63;
      padding:1px 4px; border-radius:4px;
    }
    .slot-clear:hover { color:#ff8a80; background: rgba(255,255,255,0.05); }
    .chord-bank-grid {
      display:grid; grid-template-columns: repeat(6, 1fr); gap:8px; margin-top:12px;
    }
    .chord-mini {
      background:#2e2018; border:1px solid #5d4037; color:#d7ccc8;
      padding:8px 6px; border-radius:6px; cursor:pointer; font-size:0.85rem;
      font-family:'Playfair Display', serif; font-weight:bold;
    }
    .chord-mini.selected { border-color: var(--gold); box-shadow: 0 0 0 2px rgba(212,175,55,0.18) inset; color: var(--gold); }
    .chord-mini.active { background: var(--gold); color:#2e2018; border-color:#fff; }
    .countdown-panel {
      background:#18100c; border: 2px solid var(--gold-dim); border-radius:6px; padding:6px 10px;
      text-align:center; min-width:92px; box-shadow: inset 0 0 18px rgba(0,0,0,0.85);
    }
    .countdown-digit { font-family:'Playfair Display', serif; font-size:1.7rem; color:var(--highlight); text-shadow: 0 0 6px rgba(212,175,55,0.35); }
.row-compact { display:flex; align-items:center; justify-content:space-between; gap:12px; }

  
    .play-row{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      flex-wrap:nowrap;
      margin-top:6px;
    }
    .play-row .btn-main{ height: 44px; }
    .btn-compact{ padding: 0 14px; font-size: 0.95rem; white-space: nowrap; width:auto; }
    .btn-row{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap:8px;
      flex-wrap:nowrap;
    }
    .btn-row button{ white-space: nowrap; }
    
    .prog-controls-row{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap:8px;
      flex-wrap:nowrap;
    }
    .prog-controls-row .note-select{ min-width: 320px; }
    .prog-controls-row button{ white-space: nowrap; }

  </style>
</head>
<body>

<div class="studio-rack">
  <div style="display:flex; justify-content:space-between; align-items:flex-end; margin-bottom: 15px; border-bottom: 1px solid #3e2723; padding-bottom: 10px;">
    <h2>BOLERO STUDIO</h2>
    <div style="display:flex; gap:8px; align-items:center;">
      <button id="btn-power" onclick="initAudio()" style="background:linear-gradient(to bottom, #d4af37, #b08d26); color:#3e2723; border:1px solid #ffe082; padding:6px 10px; cursor:pointer; font-size:0.7rem; font-weight:bold; font-family:'Playfair Display', serif; text-transform:uppercase;">B·∫¨T ƒê√ÄN</button>
      <button onclick="applyDefaultPreset()" style="background:transparent; color:#8d6e63; border:1px solid #5d4037; padding:5px 10px; cursor:pointer; font-size:0.7rem;">‚Ü∫ Reset M·∫∑c ƒê·ªãnh</button>
    </div>
  </div>

  <div class="display-section">
    <div class="eq-controls" style="display:flex; gap: 20px;">
      <div class="knob-group">
        <span class="knob-label">BASS</span>
        <input type="range" class="eq-slider" min="-10" max="10" value="4" oninput="updateEQ('low', this.value)">
      </div>
      <div class="knob-group">
        <span class="knob-label">TREBLE</span>
        <input type="range" class="eq-slider" min="-10" max="10" value="2" oninput="updateEQ('high', this.value)">
      </div>
    </div>
    <div style="text-align:right;">
      <div class="status-grid">
        <div class="status-value" id="str-display">---</div>
        <div class="status-value" id="chord-display">Am</div>
        <div class="status-label">D√ÇY ƒêANG G·∫¢Y</div>
        <div class="status-label">H·ª¢P √ÇM</div>
      </div>
    </div>
  </div>

  <div class="timeline-wrapper" id="timeline"></div>

  <div class="control-deck">
    <div style="text-align:center;">
      <div class="knob-label">T·ªêC ƒê·ªò (BPM)</div>
      <div style="display:flex; align-items:center; gap:10px; justify-content:center;">
        <input type="range" id="bpm" min="50" max="120" value="75" style="width:100%; accent-color:var(--gold);" oninput="document.getElementById('bpm-v').innerText=this.value">
        <span id="bpm-v" style="font-family:'Playfair Display'; color:var(--gold); font-size: 1.2rem; font-weight:bold;">75</span>
      </div>
    </div>
    <div class="play-row">
      <button id="btn-play" class="btn-main btn-compact" onclick="togglePlay()">‚ñ∂ B·∫ÆT ƒê·∫¶U</button>
      <button id="btn-countdown" class="btn-main btn-compact" onclick="toggleCountdown()">‚è± V√ÄO B√ÄI</button>
      <div id="countdown-panel" class="countdown-panel" style="display:none;">
        <div id="countdown-digit" class="countdown-digit">4.0</div>
</div>
    </div>
    <div style="text-align:right;">
      <div class="knob-label">V√íNG H·ª¢P √ÇM</div>
      <label class="switch" style="cursor:pointer;">
        <input type="checkbox" id="chk-auto" checked> 
        <span class="slider-toggle">T·∫ÆT</span> / <span class="slider-toggle" style="color:var(--gold)">B·∫¨T (m·ªói √¥ nh·ªãp)</span>
      </label>
    </div>
  </div>


  
  <div class="control-deck split-deck" style="margin-top: -10px;">
    <div style="text-align:left;">
      <div class="knob-label">PRESET BOLERO</div>
      <select id="feel-preset" class="note-select" style="width:100%; padding:8px 10px;" onchange="applyFeelPreset(this.value)">
        <option value="nhau_easy" selected>Nh·∫≠u d·ªÖ h√°t (khuy√™n d√πng)</option>
        <option value="nhau_crowd">Nh·∫≠u ƒë√¥ng ng∆∞·ªùi (nh·ªãp ƒë·ª©ng)</option>
        <option value="nhau_fast">Nh·∫≠u vui nhanh</option>
        <option value="tap_vao_bai">T·∫≠p v√†o b√†i (count-in 2 √¥)</option>
        <option value="custom">T√πy ch·ªânh</option>
      </select>
      <div class="section-sub">Preset gi√∫p nhanh ‚Äúƒë·ªám h√°t nh·∫≠u‚Äù. Ph·∫ßn n√¢ng cao (Humanize/Groove/Accent/Dynamics/Output...) n·∫±m b√™n d∆∞·ªõi (m·∫∑c ƒë·ªãnh ·∫©n).</div>
    </div>

    <div style="text-align:left;">
      <div class="knob-label">TI·∫æNG GUITAR</div>
      <div class="inline-row">
        <select id="guitar-preset" class="note-select" style="width:100%; padding:8px 10px;" onchange="applyGuitarPreset(this.value)">
        <option value="auto" selected>T·ª± ƒë·ªông (khuy√™n d√πng)</option>
        <option value="sf_nylon_musyng">Nylon - MusyngKite (Soundfont)</option>
        <option value="sf_nylon_fluid">Nylon - FluidR3_GM (Soundfont)</option>
        <option value="sf_steel_fluid">Steel - FluidR3_GM (Soundfont)</option>
        <option value="waf_nylon_godin">Nylon Godin - LK (WebAudioFont)</option>
        <option value="waf_steel_acoustic">Steel Acoustic (WebAudioFont)</option>
        <option value="waf_jazz_generaluser">Electric Jazz (WebAudioFont)</option>
        <option value="waf_clean_sbawe32">Electric Clean (WebAudioFont)</option>
        <option value="waf_muted_sbawe32">Electric Muted (WebAudioFont)</option>
      </select>
        <button class="btn-small" id="btn-reload-guitar" onclick="reloadGuitar()" style="height:44px;">T·∫¢I L·∫†I</button>
      </div>
      <div class="section-sub" id="guitar-status">Ch∆∞a t·∫£i ti·∫øng (b·∫•m B·∫¨T ƒê√ÄN).</div>
      <div class="section-sub"><span style="color:#8d6e63;">Tr·∫°ng th√°i:</span> <span id="guitar-source">‚Äî</span></div>
    </div>
  </div>
<details id="adv-settings" class="details-panel">
    <summary>Tu·ª≥ ch·ªânh n√¢ng cao</summary>

    <div class="control-deck" style="grid-template-columns: 1fr 1fr 1fr; margin-top: -10px;">
      <div style="text-align:center;">
        <div class="knob-label">HUMANIZE (ms)</div>
        <div style="display:flex; align-items:center; gap:10px; justify-content:center;">
          <input type="range" id="humanize" min="0" max="20" value="6" style="width:100%; accent-color:var(--gold);" oninput="setFeel('humanize', this.value); document.getElementById('humanize-v').innerText=this.value">
          <span id="humanize-v" style="font-family:'Playfair Display'; color:var(--gold); font-size: 1.1rem; font-weight:bold;">6</span>
        </div>
      </div>
      <div style="text-align:center;">
        <div class="knob-label">GROOVE (ms)</div>
        <div style="display:flex; align-items:center; gap:10px; justify-content:center;">
          <input type="range" id="groove" min="-25" max="25" value="10" style="width:100%; accent-color:var(--gold);" oninput="setFeel('groove', this.value); document.getElementById('groove-v').innerText=this.value">
          <span id="groove-v" style="font-family:'Playfair Display'; color:var(--gold); font-size: 1.1rem; font-weight:bold;">10</span>
        </div>
      </div>
      <div style="text-align:center;">
        <div class="knob-label">REVERB</div>
        <div style="display:flex; align-items:center; gap:10px; justify-content:center;">
          <input type="range" id="reverb" min="0" max="40" value="18" style="width:100%; accent-color:var(--gold);" oninput="setFeel('reverb', this.value); document.getElementById('reverb-v').innerText=this.value">
          <span id="reverb-v" style="font-family:'Playfair Display'; color:var(--gold); font-size: 1.1rem; font-weight:bold;">18</span>
        </div>
      </div>
    </div>

    <div class="control-deck" style="grid-template-columns: 1fr 1fr 1fr; margin-top: 8px;">
      <div style="text-align:center;">
        <div class="knob-label">ACCENT (%)</div>
        <div style="display:flex; align-items:center; gap:10px; justify-content:center;">
          <input type="range" id="accent" min="0" max="50" value="22" style="width:100%; accent-color:var(--gold);" oninput="setFeel('accent', this.value); document.getElementById('accent-v').innerText=this.value">
          <span id="accent-v" style="font-family:'Playfair Display'; color:var(--gold); font-size: 1.1rem; font-weight:bold;">22</span>
        </div>
      </div>
      <div style="text-align:center;">
        <div class="knob-label">DYNAMICS (%)</div>
        <div style="display:flex; align-items:center; gap:10px; justify-content:center;">
          <input type="range" id="dyn" min="0" max="25" value="8" style="width:100%; accent-color:var(--gold);" oninput="setFeel('dyn', this.value); document.getElementById('dyn-v').innerText=this.value">
          <span id="dyn-v" style="font-family:'Playfair Display'; color:var(--gold); font-size: 1.1rem; font-weight:bold;">8</span>
        </div>
      </div>
      <div style="text-align:center;">
        <div class="knob-label">OUTPUT</div>
        <div style="display:flex; align-items:center; gap:10px; justify-content:center;">
          <input type="range" id="out" min="40" max="120" value="95" style="width:100%; accent-color:var(--gold);" oninput="setFeel('out', this.value); document.getElementById('out-v').innerText=this.value">
          <span id="out-v" style="font-family:'Playfair Display'; color:var(--gold); font-size: 1.1rem; font-weight:bold;">95</span>
        </div>
      </div>
    </div>

    <div style="display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom: 12px; margin-top: 10px; padding: 10px 12px; background:#241914; border-radius:6px; border:1px solid #3e2723;">
      <div style="display:flex; align-items:center; gap:10px;">
        <div class="knob-label" style="margin:0;">COUNT-IN</div>
        <select id="countin" class="note-select" style="width:auto; padding:6px 10px;" onchange="setFeel('countin', this.value)">
          <option value="0" selected>T·∫Øt</option>
          <option value="1">1 √¥ nh·ªãp</option>
          <option value="2">2 √¥ nh·ªãp</option>
        </select>
      </div>
      <div style="display:flex; align-items:center; gap:12px;">
        <label class="switch" style="cursor:pointer; display:flex; align-items:center; gap:8px;">
          <input type="checkbox" id="chk-cuebeep" onchange="setFeel('cuebeep', this.checked ? 1 : 0)">
          <span class="slider-toggle" style="color:var(--gold)">BEEP CUE</span>
        </label>
        <label class="switch" style="cursor:pointer; display:flex; align-items:center; gap:8px;">
          <input type="checkbox" id="chk-met" onchange="setFeel('met', this.checked ? 1 : 0)">
          <span class="slider-toggle" style="color:var(--gold)">MET</span>
        </label>
      </div>
    </div>

    <div class="section-sub">G·ª£i √Ω nhanh: ‚ÄúHumanize‚Äù cao ‚Üí b·ªõt m√°y m√≥c; ‚ÄúGroove‚Äù d∆∞∆°ng ‚Üí ‚Äúr·ª•ng‚Äù nh·∫π ·ªü fill; ‚ÄúAccent/Dynamics‚Äù cao ‚Üí n·ªïi nh·ªãp h∆°n nh∆∞ng d·ªÖ g·∫Øt.</div>
  </details>
  <div class="section-block">
    <div class="section-header">
      <div>
        <div class="knob-label" style="margin:0;">V√íNG H·ª¢P √ÇM (2 D√íNG, 6 √î)</div>
        <div class="section-sub">K√©o h·ª£p √¢m (·ªü m·ª•c b√™n d∆∞·ªõi) v√†o √¥, ho·∫∑c ch·∫°m ch·ªçn h·ª£p √¢m r·ªìi ch·∫°m √¥ ƒë·ªÉ ƒë·∫∑t. N·∫øu √¥ tr·ªëng: t·ª± b·∫Øt h·ª£p √¢m g·∫ßn nh·∫•t (c√≥ quay v√≤ng).</div>
      </div>
      <div class="prog-controls-row">
        <select id="prog-preset" class="note-select" style="width:100%; padding:8px 10px;" onchange="applyChordProgPreset(this.value)">
          <option value="am_basic" selected>Bolero Am c∆° b·∫£n (i-iv-V7)</option>
          <option value="am_turn">Bolero Am c√≥ turnaround</option>
          <option value="c_basic">Bolero C c∆° b·∫£n (I-IV-V7)</option>
          <option value="c_turn">Bolero C c√≥ turnaround</option>
          <option value="g_basic">Bolero G c∆° b·∫£n (I-IV-V7)</option>
        </select>
        <button class="btn-small" onclick="applyChordLoop()" id="btn-apply-loop">√ÅP D·ª§NG</button>
        <button class="btn-small" onclick="clearChordLoop()">Xo√° v√≤ng</button>
      </div>
    </div>

    <div id="prog-grid" class="prog-grid"></div>
  </div>

  <details id="chord-bank" class="details-panel" style="margin-top:12px;" open>
    <summary>H·ª£p √¢m m·ªü r·ªông</summary>
    <div class="section-sub">M·∫πo: ch·ªçn h·ª£p √¢m (n√≥ s·∫Ω s√°ng vi·ªÅn), sau ƒë√≥ ch·∫°m v√†o √¥ trong v√≤ng h·ª£p √¢m ƒë·ªÉ ƒë·∫∑t. Tr√™n m√°y t√≠nh c√≥ th·ªÉ k√©o-th·∫£.</div>
    <div id="chord-bank-grid" class="chord-bank-grid"></div>
  </details>
<div style="margin-top:15px; display:flex; justify-content:space-between; align-items:center;">
    <div id="msg-box" style="font-size:0.8rem; color:#8d6e63; font-style:italic;">S·∫µn s√†ng ph·ª•c v·ª•...</div>
    <button onclick="applyNotesToPercent()" style="background:#2e2018; color:var(--gold); border:1px solid var(--gold); padding:6px 15px; cursor:pointer; font-weight:bold; font-size:0.8rem; font-family:'Playfair Display';">C·∫¨P NH·∫¨T NH·ªäP</button>
  </div>
</div>

<script>
  // CONFIG
  const NOTES_VAL = [
    { label: "ùÖù Tr√≤n (4.0)", val: 4.0 }, { label: "ùÖû Tr·∫Øng (2.0)", val: 2.0 },
    { label: "‚ô© ƒêen (1.0)", val: 1.0 }, { label: "‚ô™ ƒê∆°n (0.5)", val: 0.5 },
    { label: "ùÖ° K√©p (0.25)", val: 0.25 }
  ];
  const DEFAULT_PRESET = [
    { label: "B√ôM", type: "bass", val: 0.5, cue: true },
    { label: "1", type: "fill", val: 0.25 },
    { label: "2", type: "fill", val: 0.25 },
    { label: "3", type: "fill", val: 0.5 },
    { label: "CH√ÅT", type: "chat", val: 0.5 },
    { label: "B√ôM", type: "bass", val: 0.5 },
    { label: "CH√ÅT", type: "chat", val: 0.5 },
    { label: "B√ôM+1", type: "bass", val: 0.5 },
    { label: "CH√ÅT", type: "chat", val: 0.5 }
  ];
  let steps = JSON.parse(JSON.stringify(DEFAULT_PRESET));
  
  let guitar = null;
  let eq = null;
  let isPlaying = false;
  let currentStep = 0;
  let timer = null;
  let currentChord = "Am";
  let barIndex = 0;
  let patternStartTime = null; // th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu √¥ nh·ªãp 1 (sau count-in)

  // FEEL / MIX CONTROLS (engine n√¢ng c·∫•p)
  const FEEL = {
    humanizeMs: 6,    // random micro-timing
    grooveMs: 10,     // delay non-bass vs bass (push/pull)
    reverbPct: 18,    // 0..40
    accentPct: 22,    // 0..50
    dynPct: 8,        // 0..25
    outPct: 95,       // 40..120
    countInBars: 0,   // 0..2
    cueBeep: false,
    metronome: false
  };
  let stepBeatStarts = []; // v·ªã tr√≠ ph√°ch b·∫Øt ƒë·∫ßu c·ªßa t·ª´ng step trong 1 √¥ nh·ªãp

  const TUNING = [40, 45, 50, 55, 59, 64];

  // H·ª£p √¢m m·ªü r·ªông (∆∞u ti√™n shape ph·ªï bi·∫øn; d√πng cho pattern bolero ng√≥n c√°i)
  const CHORDS = {
    "Am":   { b: 5, f: [0, 0, 2, 2, 1, 0] },
    "A":    { b: 5, f: [0, 0, 2, 2, 2, 0] },
    "A7":   { b: 5, f: [0, 0, 2, 0, 2, 0] },

    "Bm":   { b: 5, f: [2, 2, 4, 4, 3, 2] },   // barre (x24432) gi·∫£n l∆∞·ª£c
    "B7":   { b: 5, f: [-1, 2, 1, 2, 0, 2] },

    "C":    { b: 5, f: [-1, 3, 2, 0, 1, 0] },
    "C7":   { b: 5, f: [-1, 3, 2, 3, 1, 0] },

    "D":    { b: 4, f: [-1, 0, 0, 2, 3, 2] },
    "Dm":   { b: 4, f: [-1, 0, 0, 2, 3, 1] },
    "D7":   { b: 4, f: [-1, 0, 0, 2, 1, 2] },

    "E":    { b: 6, f: [0, 2, 2, 1, 0, 0] },
    "Em":   { b: 6, f: [0, 2, 2, 0, 0, 0] },
    // E7 gi·ªØ bass d√¢y 5 cho d·ªÖ t·∫≠p (theo video ph·ªï bi·∫øn)
    "E7":   { b: 5, f: [0, 2, 0, 1, 0, 0] },

    "F":    { b: 6, f: [1, 3, 3, 2, 1, 1] },   // barre
    "Fmaj7":{ b: 5, f: [-1, 3, 3, 2, 1, 0] },  // d·ªÖ h∆°n

    "G":    { b: 6, f: [3, 2, 0, 0, 0, 3] },
    "G7":   { b: 6, f: [3, 2, 0, 0, 0, 1] },

    "Bb":   { b: 5, f: [-1, 1, 3, 3, 3, 1] }   // barre
  };

  // Preset v√≤ng h·ª£p √¢m chu·∫©n bolero (12 √¥ = 12 √¥ nh·ªãp; mu·ªën 2 √¥ nh·ªãp/1 h·ª£p √¢m th√¨ l·∫∑p l·∫°i)
  const CHORD_PROG_PRESETS = {
    am_basic: ["Am","Am","Dm","Dm","E7","E7","Am","Am","Dm","Dm","E7","E7"],
    am_turn:  ["Am","Am","Dm","Dm","E7","E7","Am","Am","Dm","E7","Am","E7"],
    c_basic:  ["C","C","F","F","G7","G7","C","C","F","F","G7","G7"],
    c_turn:   ["C","C","F","F","G7","G7","C","C","Dm","G7","C","G7"],
    g_basic:  ["G","G","C","C","D7","D7","G","G","C","C","D7","D7"]
  };

  let chordProg = [...CHORD_PROG_PRESETS.am_basic];
  let chordProgApplied = [...chordProg];
  let chordProgDirty = false;
  let selectedChord = "Am"; // chord ƒë·ªÉ g√°n v√†o √¥ khi ng∆∞·ªùi d√πng ch·ªçn

  // UI RENDERING
  const timeline = document.getElementById('timeline');
  function renderTimeline() {
    timeline.innerHTML = '';
    const totalVal = steps.reduce((sum, s) => sum + s.val, 0);
    steps.forEach((step, idx) => {
      const pct = (step.val / totalVal) * 100;
      step.pct = pct; 
      const el = document.createElement('div');
      el.className = `segment type-${step.type} ${step.cue ? 'cue-point' : ''}`;
      el.id = `seg-${idx}`;
      el.style.width = `${pct}%`;
      let opts = "";
      NOTES_VAL.forEach(n => {
        const sel = (step.val === n.val) ? "selected" : "";
        opts += `<option value="${n.val}" ${sel}>${n.label}</option>`;
      });
      const cueHtml = step.cue ? `<div class="cue-icon">H√ÅT</div>` : '';
      el.innerHTML = `${cueHtml}<span style="font-weight:bold; font-size:0.75rem; margin-top:5px;">${step.label}</span><select class="note-select" onchange="updateStepVal(${idx}, this.value)">${opts}</select>`;
      timeline.appendChild(el);
    });
    validateTotal(totalVal);
    computeStepBeatStarts();
  }
  function updateStepVal(idx, val) {
    steps[idx].val = parseFloat(val);
    document.getElementById('msg-box').innerText = "Vui l√≤ng b·∫•m 'C·∫¨P NH·∫¨T NH·ªäP' ƒë·ªÉ √°p d·ª•ng.";
    document.getElementById('msg-box').style.color = "#d4af37";
  }
  function validateTotal(total) {
    const msg = document.getElementById('msg-box');
    if(total === 4.0) { msg.innerText = "‚úì Nh·ªãp 4/4 Chu·∫©n (4.0 Ph√°ch)"; msg.style.color = "#4caf50"; }
    else { msg.innerText = `‚ö† L∆∞u √Ω: T·ªïng ƒëang l√† ${total} Ph√°ch (Chu·∫©n l√† 4.0)`; msg.style.color = "#ff5252"; }
  }

  function computeStepBeatStarts() {
    stepBeatStarts = [];
    let acc = 0;
    for (let i = 0; i < steps.length; i++) {
      stepBeatStarts[i] = acc;
      acc += steps[i].val;
    }
  }

  window.applyNotesToPercent = function() { renderTimeline(); }
  window.applyDefaultPreset = function() {
    if (isPlaying) togglePlay();
    steps = JSON.parse(JSON.stringify(DEFAULT_PRESET));
    renderTimeline();
    try {
      const fp = document.getElementById('feel-preset');
      if (fp) { fp.value = 'nhau_easy'; window.applyFeelPreset('nhau_easy'); }
    } catch(e) {}
    try {
      const gp = document.getElementById('guitar-preset');
      if (gp) { gp.value = 'auto'; window.applyGuitarPreset('auto'); }
    } catch(e) {}
  }

  // === PRESET BOLERO (SETTINGS) ===
  let applyingFeelPreset = false;

  function markFeelPresetCustom() {
    const sel = document.getElementById('feel-preset');
    if (sel && sel.value !== "custom" && !applyingFeelPreset) sel.value = "custom";
  }

  const FEEL_PRESETS = {
    nhau_easy:   { bpm: 84, humanize: 6, groove: 12, accent: 16, dyn: 8,  reverb: 12, out: 95, countin: 0, cuebeep: 0, met: 0 },
    nhau_crowd:  { bpm: 88, humanize: 3, groove: 8,  accent: 22, dyn: 6,  reverb: 8,  out: 98, countin: 0, cuebeep: 0, met: 0 },
    nhau_fast:   { bpm: 98, humanize: 4, groove: 6,  accent: 18, dyn: 8,  reverb: 10, out: 98, countin: 0, cuebeep: 0, met: 0 },
    tap_vao_bai: { bpm: 80, humanize: 3, groove: 8,  accent: 18, dyn: 5,  reverb: 8,  out: 95, countin: 2, cuebeep: 1, met: 0 },
    custom:      null
  };

  window.applyFeelPreset = function(key) {
    if (!FEEL_PRESETS[key]) { return; }
    applyingFeelPreset = true;
    const p = FEEL_PRESETS[key];

    // BPM
    const bpmEl = document.getElementById('bpm');
    const bpmV  = document.getElementById('bpm-v');
    if (bpmEl) bpmEl.value = String(p.bpm);
    if (bpmV)  bpmV.innerText = String(p.bpm);

    // sliders + labels
    const setSlider = (id, v, labelId, feelKey) => {
      const el = document.getElementById(id);
      const lb = document.getElementById(labelId);
      if (el) el.value = String(v);
      if (lb) lb.innerText = String(v);
      window.setFeel(feelKey, v);
    };

    setSlider("humanize", p.humanize, "humanize-v", "humanize");
    setSlider("groove",   p.groove,   "groove-v",   "groove");
    setSlider("reverb",   p.reverb,   "reverb-v",   "reverb");
    setSlider("accent",   p.accent,   "accent-v",   "accent");
    setSlider("dyn",      p.dyn,      "dyn-v",      "dyn");
    setSlider("out",      p.out,      "out-v",      "out");

    // count-in + toggles
    const ci = document.getElementById('countin');
    if (ci) { ci.value = String(p.countin); window.setFeel("countin", p.countin); }

    const cb = document.getElementById('chk-cuebeep');
    if (cb) { cb.checked = !!p.cuebeep; window.setFeel("cuebeep", p.cuebeep ? 1 : 0); }

    const met = document.getElementById('chk-met');
    if (met) { met.checked = !!p.met; window.setFeel("met", p.met ? 1 : 0); }

    applyingFeelPreset = false;

    // ƒë·∫£m b·∫£o preset kh√¥ng b·ªã set v·ªÅ custom b·ªüi setFeel
    const sel = document.getElementById('feel-preset');
    if (sel) sel.value = key;

    const msg = document.getElementById('msg-box');
    if (msg) { msg.innerText = `ƒê√£ √°p d·ª•ng preset: ${sel.options[sel.selectedIndex].text}`; msg.style.color = "#8d6e63"; }
  };

  // Apply default preset on load (match dropdown default)
  setTimeout(() => { try { window.applyFeelPreset("nhau_easy"); } catch(e) {} }, 0);


  // === V√íNG H·ª¢P √ÇM (2 D√íNG, 6 √î) ===
// Quy ∆∞·ªõc: √¥ tr·ªëng = B·ªé QUA (r√∫t ng·∫Øn v√≤ng). Kh√¥ng gi·ªØ h·ª£p √¢m tr∆∞·ªõc ƒë√≥.
let chordProgActiveIdx = [];
let chordProgActiveChords = [];

function recomputeActiveChordProg() {
  chordProgActiveIdx = [];
  chordProgActiveChords = [];
  const arr = chordProgApplied;
  if (!Array.isArray(arr)) return;
  for (let i = 0; i < arr.length; i++) {
    const c = arr[i];
    if (c && CHORDS[c]) {
      chordProgActiveIdx.push(i);
      chordProgActiveChords.push(c);
    }
  }
}

function resolveChordAtBar(bar) {
  if (!chordProgActiveChords.length) return { chord: currentChord, idx: -1 };
  const n = chordProgActiveChords.length;
  const pos = ((bar % n) + n) % n;
  return { chord: chordProgActiveChords[pos], idx: chordProgActiveIdx[pos] };
}

function getChordForBar(bar) {
  return resolveChordAtBar(bar).chord;
}

function updateChordLoopCurrent() {
  const ck = document.getElementById('chk-auto');
  const autoOn = !!(ck && ck.checked);
  const r = resolveChordAtBar(barIndex);
  const hi = r.idx;
  for (let i = 0; i < 12; i++) {
    const el = document.getElementById(`prog-slot-${i}`);
    if (!el) continue;
    el.classList.toggle('current', autoOn && isPlaying && (i === hi));
  }
}

// init once
recomputeActiveChordProg();

  function markChordProgDirty() {
    chordProgDirty = true;
    const msg = document.getElementById('msg-box');
    if (msg) { msg.innerText = "ƒê√£ ch·ªânh v√≤ng h·ª£p √¢m. Nh·∫•n √ÅP D·ª§NG ho·∫∑c b·∫•m PLAY ƒë·ªÉ ch·∫°y ƒë√∫ng v√≤ng."; msg.style.color = "#8d6e63"; }
  }

  function applyChordLoopInternal(showMsg = true, enableAuto = true) {
    chordProgApplied = [...chordProg];
    try { recomputeActiveChordProg(); } catch(e) {}
    chordProgDirty = false;

    if (enableAuto) {
      const ck = document.getElementById('chk-auto');
      if (ck) ck.checked = true;
    }

    if (showMsg) {
      const msg = document.getElementById('msg-box');
      if (msg) { msg.innerText = "ƒê√£ √°p d·ª•ng v√≤ng h·ª£p √¢m."; msg.style.color = "#8d6e63"; }
    }

    if (document.getElementById('chk-auto').checked) {
      const c = getChordForBar(isPlaying ? barIndex : 0);
      if (c) setChord(c, true);
    }
    updateChordLoopCurrent();
  }

  window.applyChordLoop = function() {
    applyChordLoopInternal(true, true);
  };

  function setProgSlot(i, chord) {
    if (i < 0 || i >= 12) return;
    chordProg[i] = chord;
    renderChordLoop();

        markChordProgDirty();
    applyChordLoopInternal(false, true);
// N·∫øu ƒëang ch·∫°y + ƒëang d√πng v√≤ng h·ª£p √¢m, cho ng∆∞·ªùi d√πng nghe ngay t·∫°i √¥ hi·ªán t·∫°i
    if (isPlaying && document.getElementById('chk-auto').checked) {
      try {
        const r = resolveChordAtBar(barIndex);
        if (r.idx === i) setChord(r.chord, true);
      } catch(e) {}
    }
  }

  function clearProgSlot(i) { setProgSlot(i, null); }

  function renderChordLoop() {
    const grid = document.getElementById("prog-grid");
    if (!grid) return;
    grid.innerHTML = "";

    for (let i = 0; i < 12; i++) {
      const chord = chordProg[i] || "";
      const el = document.createElement("div");
      el.id = `prog-slot-${i}`;
      el.className = `prog-slot ${chord ? "filled" : ""}`;
      el.title = chord ? `√î ${i+1}: ${chord}` : `√î ${i+1}: (tr·ªëng)`;

      el.innerHTML = `
        <div class="slot-index">${i+1}</div>
        ${chord ? `<div class="slot-clear" onclick="event.stopPropagation(); clearProgSlot(${i});">√ó</div>` : ""}
        <div>${chord || "‚Äî"}</div>
      `;

      el.addEventListener("click", () => {
        if (selectedChord && CHORDS[selectedChord]) setProgSlot(i, selectedChord);
      });

      el.addEventListener("dragover", (ev) => { ev.preventDefault(); el.classList.add("dragover"); });
      el.addEventListener("dragleave", () => { el.classList.remove("dragover"); });
      el.addEventListener("drop", (ev) => {
        ev.preventDefault();
        el.classList.remove("dragover");
        const c = ev.dataTransfer.getData("text/chord");
        if (c && CHORDS[c]) setProgSlot(i, c);
      });

      grid.appendChild(el);
    }

    updateChordLoopCurrent();
  }

  window.applyChordProgPreset = function(key) {
    const preset = CHORD_PROG_PRESETS[key] || CHORD_PROG_PRESETS.am_basic;
    chordProg = [...preset];
    renderChordLoop();
    markChordProgDirty();
    applyChordLoopInternal(false, true);
const msg = document.getElementById('msg-box');
    const sel = document.getElementById('prog-preset');
    if (msg && sel) { msg.innerText = `ƒê√£ n·∫°p v√≤ng h·ª£p √¢m: ${sel.options[sel.selectedIndex].text}`; msg.style.color = "#8d6e63"; }

    // N·∫øu ƒëang d√πng v√≤ng h·ª£p √¢m: c·∫≠p nh·∫≠t h·ª£p √¢m hi·ªán t·∫°i theo barIndex
    if (document.getElementById('chk-auto').checked) {
      const c = getChordForBar(isPlaying ? barIndex : 0);
      if (c) setChord(c, true);
    }
  };

  window.clearChordLoop = function() {
    chordProg = new Array(12).fill(null);
    renderChordLoop();
    markChordProgDirty();
    applyChordLoopInternal(true, true);
const msg = document.getElementById('msg-box');
    if (msg) { msg.innerText = "ƒê√£ xo√° v√≤ng h·ª£p √¢m (√¥ tr·ªëng s·∫Ω b·ªã b·ªè qua)."; msg.style.color = "#8d6e63"; }
  };

  // === CHORD BANK (COLLAPSED) ===
  function renderChordBank() {
    const bank = document.getElementById("chord-bank-grid");
    if (!bank) return;

    const order = [
      "Am","Dm","E7","C","G7","F",
      "Em","D","A","A7","D7","G",
      "C7","E","Fmaj7","B7","Bm","Bb"
    ].filter(x => CHORDS[x]);

    // th√™m c√°c h·ª£p √¢m c√≤n l·∫°i (n·∫øu c√≥)
    const rest = Object.keys(CHORDS).filter(x => !order.includes(x)).sort();
    const all = [...order, ...rest];

    bank.innerHTML = "";
    all.forEach(name => {
      const b = document.createElement("button");
      b.className = "chord-mini";
      b.innerText = name;
      b.dataset.chord = name;
      b.draggable = true;

      b.addEventListener("dragstart", (ev) => {
        ev.dataTransfer.setData("text/chord", name);
      });

      b.addEventListener("click", () => {
        selectedChord = name;
        refreshChordButtons();

        // n·∫øu kh√¥ng d√πng v√≤ng h·ª£p √¢m -> ƒë·ªïi h·ª£p √¢m ngay
        if (!document.getElementById('chk-auto').checked) setChord(name, false);

        const msg = document.getElementById('msg-box');
        if (msg) { msg.innerText = `ƒê√£ ch·ªçn h·ª£p √¢m: ${name}. Ch·∫°m v√†o √¥ ƒë·ªÉ ƒë·∫∑t v√†o v√≤ng.`; msg.style.color = "#8d6e63"; }
      });

      bank.appendChild(b);
    });

    refreshChordButtons();
  }

  function refreshChordButtons() {
    document.querySelectorAll(".chord-mini").forEach(btn => {
      const c = btn.dataset.chord;
      btn.classList.toggle("active", c === currentChord);
      btn.classList.toggle("selected", c === selectedChord);
    });
  }

  // === N√öT V√ÄO B√ÄI (ƒê·∫æM NG∆Ø·ª¢C GI√ÇY LI√äN T·ª§C) ===
  let countdownOn = false;
  let countdownTimer = null;

  function countdownSecLeft() {
    // N·∫øu ƒëang ch·∫°y -> ƒë·∫øm t·ªõi "nh·ªãp 1" k·∫ø ti·∫øp (ƒë·∫ßu √¥ nh·ªãp)
    if (isPlaying && patternStartTime != null) {
      const bpm = parseFloat(document.getElementById('bpm').value || "80");
      const beatDur = 60 / Math.max(30, Math.min(220, bpm));
      const barLen = 4 * beatDur;

      const now = Tone.now();
      const elapsed = Math.max(0, now - patternStartTime);
      const mod = elapsed % barLen;
      const left = barLen - mod;
      return left;
    }

    // Kh√¥ng ch·∫°y -> ƒë·∫øm v√≤ng 4 gi√¢y ƒë·ªÉ ng∆∞·ªùi h√°t l·∫•y nh·ªãp (visual)
    const now = performance.now() / 1000;
    const barLen = 4.0;
    const mod = now % barLen;
    return barLen - mod;
  }

  function updateCountdownUI() {
    const panel = document.getElementById("countdown-panel");
    const digit = document.getElementById("countdown-digit");
    if (!panel || !digit) return;

    const left = countdownSecLeft();
    digit.innerText = left.toFixed(left < 10 ? 1 : 0);
  }

  window.toggleCountdown = function() {
    countdownOn = !countdownOn;

    const panel = document.getElementById("countdown-panel");
    const btn = document.getElementById("btn-countdown");
    if (!panel || !btn) return;

    if (countdownOn) {
      panel.style.display = "block";
      btn.innerText = "‚úï T·∫ÆT V√ÄO B√ÄI";
      btn.classList.add("stop");
      updateCountdownUI();
      if (countdownTimer) clearInterval(countdownTimer);
      countdownTimer = setInterval(updateCountdownUI, 50);
    } else {
      panel.style.display = "none";
      btn.innerText = "‚è± V√ÄO B√ÄI";
      btn.classList.remove("stop");
      if (countdownTimer) { clearInterval(countdownTimer); countdownTimer = null; }
    }
  };

  // render chord UI immediately
  setTimeout(() => {
    try { renderChordLoop(); renderChordBank(); } catch(e) {}
  }, 0);

// === AUDIO ENGINE (UPGRADED V4 - gi·ªØ "CH√ÅT" nguy√™n b·∫£n) ===
let audio = null; // { ctx, input, low, high, convolver, wet, dry, sum, comp, limiter, master, analyser }

function clamp(x, lo, hi) { return Math.max(lo, Math.min(hi, x)); }

function buildImpulseResponse(ctx, seconds = 1.2, decay = 2.2) {
  const sr = ctx.sampleRate || 44100;
  const len = Math.max(1, Math.floor(sr * seconds));
  const buf = ctx.createBuffer(2, len, sr);
  for (let ch = 0; ch < 2; ch++) {
    const data = buf.getChannelData(ch);
    for (let i = 0; i < len; i++) {
      const t = i / len;
      const env = Math.pow(1 - t, decay);
      data[i] = (Math.random() * 2 - 1) * env;
    }
  }
  return buf;
}

async function ensureSoundfontPlayer() {
  if (window.Soundfont && window.Soundfont.instrument) return true;

  const candidates = [
    "https://unpkg.com/soundfont-player@0.12.0/dist/soundfont-player.min.js",
    "https://cdn.jsdelivr.net/npm/soundfont-player@0.12.0/dist/soundfont-player.min.js"
  ];

  for (const url of candidates) {
    try {
      await new Promise((resolve, reject) => {
        const s = document.createElement("script");
        s.src = url;
        s.async = true;
        s.onload = resolve;
        s.onerror = reject;
        document.head.appendChild(s);
      });
      if (window.Soundfont && window.Soundfont.instrument) return true;
    } catch (e) {
      console.warn("Load soundfont-player failed:", url, e);
    }
  }
  return false;
}

// === OPTIONAL BACKEND: WebAudioFont (th∆∞ vi·ªán kh√°c ƒë·ªÉ ch·ªçn ti·∫øng guitar) ===
async function ensureWebAudioFont() {
  if (window.WebAudioFontPlayer) return true;
  const candidates = [
    "https://surikov.github.io/webaudiofont/npm/dist/WebAudioFontPlayer.js",
    "https://cdn.jsdelivr.net/npm/webaudiofont@2.5.0/dist/WebAudioFontPlayer.js"
  ];
  for (const url of candidates) {
    try {
      await new Promise((resolve, reject) => {
        const s = document.createElement("script");
        s.src = url;
        s.async = true;
        s.onload = resolve;
        s.onerror = reject;
        document.head.appendChild(s);
      });
      if (window.WebAudioFontPlayer) return true;
    } catch (e) {
      console.warn("Load WebAudioFontPlayer failed:", url, e);
    }
  }
  return false;
}

function noteNameToMidi(note) {
  // note: "C4", "C#4", "Db3", "E2"
  if (typeof note === "number") return note;
  if (!note || typeof note !== "string") return 60;
  const m = note.match(/^([A-Ga-g])([#b]?)(-?\d+)$/);
  if (!m) return 60;
  const letter = m[1].toUpperCase();
  const acc = m[2];
  const octave = parseInt(m[3], 10);
  const base = { C:0, D:2, E:4, F:5, G:7, A:9, B:11 }[letter] ?? 0;
  const semi = base + (acc === "#" ? 1 : acc === "b" ? -1 : 0);
  return (octave + 1) * 12 + semi;
}

let wafPlayer = null;
let wafPresetVar = null;

// Guitar preset catalog
const GUITAR_PRESETS = {
  auto: { label: "T·ª± ƒë·ªông", engine: "auto" },

  // Soundfont-player
  sf_nylon_musyng: { label: "Nylon - MusyngKite (Soundfont)", engine: "soundfont", name: "acoustic_guitar_nylon", soundfont: "MusyngKite", gain: 2.4 },
  sf_nylon_fluid:  { label: "Nylon - FluidR3_GM (Soundfont)", engine: "soundfont", name: "acoustic_guitar_nylon", soundfont: "FluidR3_GM", gain: 2.2 },
  sf_steel_fluid:  { label: "Steel - FluidR3_GM (Soundfont)", engine: "soundfont", name: "acoustic_guitar_steel", soundfont: "FluidR3_GM", gain: 2.2 },

  // WebAudioFont (dynamic loading)
  waf_nylon_godin:     { label: "Nylon Godin - LK (WebAudioFont)", engine: "waf", path: "https://surikov.github.io/webaudiofontdata/sound/0240_LK_Godin_Nylon_SF2_file.js", varName: "_tone_0240_LK_Godin_Nylon_SF2_file", vol: 0.95 },
  waf_steel_acoustic:  { label: "Steel Acoustic (WebAudioFont)", engine: "waf", path: "https://surikov.github.io/webaudiofontdata/sound/0250_Acoustic_Guitar_sf2_file.js", varName: "_tone_0250_Acoustic_Guitar_sf2_file", vol: 0.95 },
  waf_jazz_generaluser:{ label: "Electric Jazz (WebAudioFont)", engine: "waf", path: "https://surikov.github.io/webaudiofontdata/sound/0260_GeneralUserGS_sf2_file.js", varName: "_tone_0260_GeneralUserGS_sf2_file", vol: 0.85 },
  waf_clean_sbawe32:   { label: "Electric Clean (WebAudioFont)", engine: "waf", path: "https://surikov.github.io/webaudiofontdata/sound/0270_SBAWE32_sf2_file.js", varName: "_tone_0270_SBAWE32_sf2_file", vol: 0.85 },
  waf_muted_sbawe32:   { label: "Electric Muted (WebAudioFont)", engine: "waf", path: "https://surikov.github.io/webaudiofontdata/sound/0280_SBAWE32_sf2_file.js", varName: "_tone_0280_SBAWE32_sf2_file", vol: 0.90 },
};

let currentGuitarPresetId = "auto";

function setGuitarStatus(text, source) {
  const st = document.getElementById("guitar-status");
  const so = document.getElementById("guitar-source");
  if (st) st.innerText = text || "";
  if (so) so.innerText = source || "";
}

function stopGuitar() {
  try { if (guitar && typeof guitar.stop === "function") guitar.stop(); } catch(e) {}
  // WebAudioFont cancel
  try { if (wafPlayer && typeof wafPlayer.cancelQueue === "function" && audio && audio.ctx) wafPlayer.cancelQueue(audio.ctx); } catch(e) {}
}

async function loadSoundfontInstrument(inst) {
  if (!audio || !audio.ctx) throw new Error("AudioContext ch∆∞a s·∫µn s√†ng.");
  const okSF = await ensureSoundfontPlayer();
  if (!okSF || !window.Soundfont) throw new Error("Kh√¥ng t·∫£i ƒë∆∞·ª£c soundfont-player.");

  const SF_BASES = [
    "https://cdn.jsdelivr.net/gh/gleitz/midi-js-soundfonts@gh-pages/",
    "https://gleitz.github.io/midi-js-soundfonts/"
  ];

  let lastErr = null;
  for (const base of SF_BASES) {
    const nameToUrl = (name, soundfont, format) => `${base}${soundfont}/${name}-${format}.js`;
    try {
      const instObj = await Soundfont.instrument(audio.ctx, inst.name, {
        soundfont: inst.soundfont,
        format: "mp3",
        nameToUrl,
        destination: audio.input,
        gain: inst.gain ?? 2.2
      });
      return { instObj, base };
    } catch (e) {
      lastErr = e;
      console.warn("Soundfont instrument load failed:", inst, "base:", base, e);
    }
  }
  throw lastErr || new Error("Kh√¥ng t·∫£i ƒë∆∞·ª£c soundfont instrument.");
}

async function loadWebAudioFontInstrument(preset) {
  if (!audio || !audio.ctx) throw new Error("AudioContext ch∆∞a s·∫µn s√†ng.");
  const ok = await ensureWebAudioFont();
  if (!ok || !window.WebAudioFontPlayer) throw new Error("Kh√¥ng t·∫£i ƒë∆∞·ª£c WebAudioFontPlayer.");

  wafPlayer = wafPlayer || new WebAudioFontPlayer();

  // Use loader (loads preset script + caches)
  await new Promise((resolve, reject) => {
    try {
      wafPlayer.loader.startLoad(audio.ctx, preset.path, preset.varName);
      wafPlayer.loader.waitLoad(() => resolve());
    } catch (e) {
      reject(e);
    }
  });

  try { wafPlayer.loader.decodeAfterLoading(audio.ctx, preset.varName); } catch(e) {}

  wafPresetVar = window[preset.varName];
  if (!wafPresetVar) throw new Error("WebAudioFont preset kh√¥ng h·ª£p l·ªá: " + preset.varName);

  // Wrapper to match soundfont-player API: guitar.play(note, time, {duration, gain})
  return {
    play: (note, when, opts = {}) => {
      const midi = noteNameToMidi(note);
      const dur = Math.max(0.03, Number(opts.duration ?? 0.12));
      const g = Number(opts.gain ?? 1.0);
      const vol = clamp((g / 2.5) * (preset.vol ?? 0.9), 0.05, 1.0);
      try {
        wafPlayer.queueWaveTable(audio.ctx, audio.input, wafPresetVar, when, midi, dur, vol);
      } catch (e) {}
    },
    stop: () => { try { if (wafPlayer && typeof wafPlayer.cancelQueue === "function") wafPlayer.cancelQueue(audio.ctx); } catch(e) {} }
  };
}

async function loadGuitarPresetById(id) {
  currentGuitarPresetId = id in GUITAR_PRESETS ? id : "auto";
  const p = GUITAR_PRESETS[currentGuitarPresetId];

  stopGuitar();

  if (p.engine === "soundfont") {
    const { instObj, base } = await loadSoundfontInstrument(p);
    guitar = instObj;
    setGuitarStatus("ƒê√£ t·∫£i: " + p.label, "Soundfont (" + p.soundfont + ")");
    return true;
  }

  if (p.engine === "waf") {
    guitar = await loadWebAudioFontInstrument(p);
    setGuitarStatus("ƒê√£ t·∫£i: " + p.label, "WebAudioFont");
    return true;
  }

  // AUTO: try soundfont list first, then WAF fallbacks
  const autoCandidates = [
    "sf_nylon_musyng",
    "sf_nylon_fluid",
    "sf_steel_fluid",
    "waf_nylon_godin",
    "waf_steel_acoustic",
    "waf_clean_sbawe32",
    "waf_muted_sbawe32",
    "waf_jazz_generaluser"
  ];

  let lastErr = null;
  for (const cid of autoCandidates) {
    const cand = GUITAR_PRESETS[cid];
    try {
      if (cand.engine === "soundfont") {
        const { instObj } = await loadSoundfontInstrument(cand);
        guitar = instObj;
        setGuitarStatus("ƒê√£ t·∫£i (Auto): " + cand.label, "Soundfont (" + cand.soundfont + ")");
        return true;
      } else if (cand.engine === "waf") {
        guitar = await loadWebAudioFontInstrument(cand);
        setGuitarStatus("ƒê√£ t·∫£i (Auto): " + cand.label, "WebAudioFont");
        return true;
      }
    } catch (e) {
      lastErr = e;
    }
  }
  setGuitarStatus("Kh√¥ng t·∫£i ƒë∆∞·ª£c ti·∫øng guitar. H√£y ƒë·ªïi preset ho·∫∑c d√πng VPN/DNS.", "L·ªói t·∫£i ti·∫øng");
  throw lastErr || new Error("Kh√¥ng t·∫£i ƒë∆∞·ª£c ti·∫øng guitar (Auto).");
}

window.applyGuitarPreset = async function(id) {
  const sel = document.getElementById("guitar-preset");
  if (sel) sel.value = id;
  const wasPlaying = isPlaying;
  if (wasPlaying) togglePlay();
  setGuitarStatus("ƒêang t·∫£i ti·∫øng...", "ƒêang t·∫£i");
  try {
    await loadGuitarPresetById(id);
  } catch (e) {
    console.warn(e);
  }
  if (wasPlaying) togglePlay();
};

window.reloadGuitar = async function() {
  const sel = document.getElementById("guitar-preset");
  const id = sel ? sel.value : currentGuitarPresetId;
  return window.applyGuitarPreset(id);
};

function applyFeelToMix() {
  if (!audio) return;

  // Reverb 0..40 -> wet 0..0.35 (gi·ªØ t·ª± nhi√™n)
  const wet = clamp(Number(FEEL.reverbPct) / 40, 0, 1) * 0.35;
  audio.wet.gain.value = wet;
  audio.dry.gain.value = 1.0;

  // Output 40..120 -> master 0.4..1.2 (sau limiter v·∫´n an to√†n)
  const out = clamp(Number(FEEL.outPct) / 100, 0.4, 1.2);
  audio.master.gain.value = out;
}

// UI hooks
window.setFeel = function(key, val) {
  try {
    if (!applyingFeelPreset) markFeelPresetCustom();
    if (key === "humanize") FEEL.humanizeMs = clamp(parseFloat(val), 0, 20);
    if (key === "groove")   FEEL.grooveMs   = clamp(parseFloat(val), -25, 25);
    if (key === "reverb")   FEEL.reverbPct  = clamp(parseFloat(val), 0, 40);
    if (key === "accent")   FEEL.accentPct  = clamp(parseFloat(val), 0, 50);
    if (key === "dyn")      FEEL.dynPct     = clamp(parseFloat(val), 0, 25);
    if (key === "out")      FEEL.outPct     = clamp(parseFloat(val), 40, 120);
    if (key === "countin")  FEEL.countInBars = clamp(parseInt(val, 10), 0, 2);
    if (key === "cuebeep")  FEEL.cueBeep    = !!Number(val);
    if (key === "met")      FEEL.metronome  = !!Number(val);
    applyFeelToMix();
  } catch(e) {}
};

// === INIT AUDIO ===
async function initAudio() {
  const btnPower = document.getElementById('btn-power');
  const msg = document.getElementById('msg-box');

  const setMsg = (text, color = "#8d6e63") => {
    if (!msg) return;
    msg.innerText = text;
    msg.style.color = color;
  };

  // N·∫øu ƒë√£ kh·ªüi t·∫°o r·ªìi th√¨ ch·ªâ c·∫ßn resume / c·∫≠p nh·∫≠t UI
  if (audio && audio.ctx) {
    try { await Tone.start(); } catch (e) {}
    try { if (audio.ctx.state === "suspended") await audio.ctx.resume(); } catch (e) {}

    if (btnPower) { btnPower.disabled = true; btnPower.innerText = "ƒê√É B·∫¨T"; }
    setMsg("√Çm thanh ƒë√£ s·∫µn s√†ng.", "#4caf50");
    return;
  }

  if (btnPower) { btnPower.disabled = true; btnPower.innerText = "ƒêANG B·∫¨T..."; }
  setMsg("ƒêang kh·ªüi t·∫°o AudioContext...", "#d4af37");

  try { await Tone.start(); } catch (e) {
    // Kh√¥ng hard-fail: m·ªôt s·ªë tr√¨nh duy·ªát v·∫´n cho rawContext
  }

  const ctx = (Tone.getContext && Tone.getContext().rawContext)
    ? Tone.getContext().rawContext
    : (Tone.context && Tone.context.rawContext)
      ? Tone.context.rawContext
      : (Tone.context && Tone.context._context)
        ? Tone.context._context
        : null;

  if (!ctx) {
    setMsg("L·ªói: Kh√¥ng l·∫•y ƒë∆∞·ª£c AudioContext. Vui l√≤ng th·ª≠ Chrome/Edge ho·∫∑c t·∫Øt ch·∫ø ƒë·ªô ti·∫øt ki·ªám pin.", "#ff5252");
    if (btnPower) { btnPower.disabled = false; btnPower.innerText = "B·∫¨T ƒê√ÄN"; }
    return;
  }

  const okSF = await ensureSoundfontPlayer();
  if (!okSF) {
    // v·∫´n ch·∫°y ƒë∆∞·ª£c v·ªõi WebAudioFont backend
    setMsg("C·∫£nh b√°o: Kh√¥ng t·∫£i ƒë∆∞·ª£c soundfont-player. B·∫°n c√≥ th·ªÉ ch·ªçn TI·∫æNG GUITAR (WebAudioFont).", "#ffcc80");
  }

  setMsg("ƒêang d·ª±ng rack √¢m thanh...", "#d4af37");

  // Build native chain (EQ + Reverb + Comp/Limiter)
  try {
    const input = ctx.createGain();
    input.gain.value = 1.0;

    const low = ctx.createBiquadFilter();
    low.type = "lowshelf";
    low.frequency.value = 180;

    const high = ctx.createBiquadFilter();
    high.type = "highshelf";
    high.frequency.value = 3500;

    const dry = ctx.createGain();
    const convolver = ctx.createConvolver();
    convolver.buffer = buildImpulseResponse(ctx, 1.25, 2.25);
    const wet = ctx.createGain();

    const sum = ctx.createGain();

    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -18;
    comp.knee.value = 24;
    comp.ratio.value = 2.5;
    comp.attack.value = 0.003;
    comp.release.value = 0.18;

    const limiter = ctx.createDynamicsCompressor();
    limiter.threshold.value = -3;
    limiter.knee.value = 0;
    limiter.ratio.value = 20;
    limiter.attack.value = 0.001;
    limiter.release.value = 0.06;

    const master = ctx.createGain();
    master.gain.value = 0.95;

    const analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;

    // Wiring
    input.connect(low);
    low.connect(high);

    high.connect(dry);
    high.connect(convolver);

    dry.connect(sum);
    convolver.connect(wet);
    wet.connect(sum);

    sum.connect(comp);
    comp.connect(limiter);
    limiter.connect(master);
    master.connect(analyser);
    analyser.connect(ctx.destination);

    audio = { ctx, input, low, high, convolver, wet, dry, sum, comp, limiter, master, analyser };

    // expose EQ for existing sliders
    eq = { low, high };

    // Apply defaults from UI & feel
    updateEQ('low', 4);
    updateEQ('high', 2);
    applyFeelToMix();
  } catch (e) {
    console.error("Rack init failed:", e);
    setMsg("L·ªói: Kh√¥ng kh·ªüi t·∫°o ƒë∆∞·ª£c rack √¢m thanh. " + (e && e.message ? e.message : ""), "#ff5252");
    if (btnPower) { btnPower.disabled = false; btnPower.innerText = "B·∫¨T ƒê√ÄN"; }
    return;
  }

  setMsg("ƒêang t·∫£i ti·∫øng guitar...", "#d4af37");

  // ƒë·ªìng b·ªô dropdown (n·∫øu c√≥)
  const selG = document.getElementById("guitar-preset");
  if (selG && selG.value) currentGuitarPresetId = selG.value;

  setGuitarStatus("ƒêang t·∫£i ti·∫øng...", "ƒêang t·∫£i");

  try {
    await loadGuitarPresetById(currentGuitarPresetId || "auto");
  } catch (e) {
    console.warn("Load guitar preset failed:", e);
    setMsg("C·∫£nh b√°o: Kh√¥ng t·∫£i ƒë∆∞·ª£c preset ti·∫øng guitar. H√£y ƒë·ªïi preset v√† b·∫•m 'T·∫¢I L·∫†I'.", "#ffcc80");
  }

  if (btnPower) { btnPower.disabled = true; btnPower.innerText = "ƒê√É B·∫¨T"; }
  setMsg("ƒê√£ b·∫≠t ƒë√†n. B·∫•m ‚ñ∂ B·∫ÆT ƒê·∫¶U ƒë·ªÉ ƒë·ªám.", "#4caf50");

  // ƒë·∫£m b·∫£o UI render ƒë·∫ßy ƒë·ªß ngay c·∫£ khi ng∆∞·ªùi d√πng ch∆∞a b·∫•m g√¨ kh√°c
  try { renderTimeline(); } catch(e) {}
  try { renderChordLoop(); } catch(e) {}
  try { renderChordBank(); } catch(e) {}
}

window.updateEQ = function(band, val) {
  if(!eq) return;
  const v = Number(val);
  if(band === 'low' && eq.low) eq.low.gain.value = v;
  if(band === 'high' && eq.high) eq.high.gain.value = v;
};

// === CLICK / METRONOME / CUE BEEP ===
function scheduleClick(time, strong = false, level = 0.12) {
  if (!audio) return;
  try {
    const osc = audio.ctx.createOscillator();
    osc.type = "square";
    osc.frequency.value = strong ? 2200 : 1400;

    const g = audio.ctx.createGain();
    g.gain.setValueAtTime(0.0001, time);
    g.gain.exponentialRampToValueAtTime(level, time + 0.002);
    g.gain.exponentialRampToValueAtTime(0.0001, time + 0.03);

    osc.connect(g);
    // ƒë∆∞a v√†o sum ƒë·ªÉ ƒëi qua comp/limiter/master (ƒë·ª° ch√≥i)
    g.connect(audio.sum);

    osc.start(time);
    osc.stop(time + 0.04);
  } catch (e) {}
}

// === PLAYBACK (AUDIO-SAFE SCHEDULER) ===
let schedulerId = null;
let nextNoteTime = 0;
let nextMetTime = 0;
let metBeat = 0;

const LOOKAHEAD_MS = 25;          // scheduler tick
const SCHEDULE_AHEAD_SEC = 0.12;  // schedule window

function togglePlay() {
  const btn = document.getElementById('btn-play');

  // Ch∆∞a b·∫≠t √¢m thanh
  if (!isPlaying && !guitar) {
    const msg = document.getElementById('msg-box');
    if (msg) { msg.innerText = "Ch∆∞a b·∫≠t ƒë√†n. B·∫•m 'B·∫¨T ƒê√ÄN' ·ªü header tr∆∞·ªõc."; msg.style.color = "#ffcc80"; }
    const bp = document.getElementById('btn-power');
    if (bp && !bp.disabled) {
      const old = bp.style.boxShadow;
      bp.style.boxShadow = "0 0 0 2px rgba(212,175,55,0.35)";
      setTimeout(() => { bp.style.boxShadow = old; }, 260);
    }
    return;
  }
  if (isPlaying) {
    isPlaying = false;
    if (schedulerId) { clearInterval(schedulerId); schedulerId = null; }
    btn.innerHTML = "‚ñ∂ B·∫ÆT ƒê·∫¶U"; btn.classList.remove('stop');
    document.querySelectorAll('.segment').forEach(s => s.classList.remove('playing'));
    document.getElementById('str-display').innerText = "---";
    const cd = document.getElementById('chord-display');
    if (cd) cd.innerText = currentChord || "---";
    patternStartTime = null;
    updateChordLoopCurrent();
    return;
  }

  isPlaying = true;
  btn.innerHTML = "‚úï D·ª™NG";

  // N·∫øu ng∆∞·ªùi d√πng v·ª´a ch·ªânh v√≤ng h·ª£p √¢m, t·ª± √°p d·ª•ng khi b·∫•m PLAY
  if (typeof chordProgDirty !== "undefined" && chordProgDirty) {
    try { applyChordLoopInternal(false, true); } catch(e) {}
  } btn.classList.add('stop');
  currentStep = 0;
  barIndex = 0;

  const bpm0 = parseFloat(document.getElementById('bpm').value || "80");
  const beatDurSec0 = 60 / Math.max(30, Math.min(220, bpm0));

  const baseStart = Tone.now() + 0.07;
  const countIn = clamp(FEEL.countInBars || 0, 0, 2);

  if (countIn > 0) {
    // schedule count-in clicks
    const beats = countIn * 4;
    for (let i = 0; i < beats; i++) {
      const t = baseStart + i * beatDurSec0;
      scheduleClick(t, (i % 4) === 0, 0.12);
    }
  }

  nextNoteTime = baseStart + (countIn * 4 * beatDurSec0);

  patternStartTime = nextNoteTime;

  // √°p d·ª•ng v√≤ng h·ª£p √¢m ngay t·ª´ √¥ nh·ªãp ƒë·∫ßu
  if (document.getElementById('chk-auto').checked) {
    const firstChord = getChordForBar(0);
    if (firstChord) setChord(firstChord, true);
  }
  updateChordLoopCurrent();

  // metronome continues from pattern start (optional)
  nextMetTime = nextNoteTime;
  metBeat = 0;

  if (schedulerId) { clearInterval(schedulerId); }
  schedulerId = setInterval(schedulerTick, LOOKAHEAD_MS);
  schedulerTick();
}

function schedulerTick() {
  if (!isPlaying) return;

  const bpm = parseFloat(document.getElementById('bpm').value || "80");
  const beatDurSec = 60 / Math.max(30, Math.min(220, bpm));
  const now = Tone.now();

  // metronome scheduling
  if (FEEL.metronome) {
    while (nextMetTime < now + SCHEDULE_AHEAD_SEC) {
      scheduleClick(nextMetTime, (metBeat % 4) === 0, 0.09);
      nextMetTime += beatDurSec;
      metBeat++;
    }
  }

  // step scheduling
  while (nextNoteTime < now + SCHEDULE_AHEAD_SEC) {
    scheduleStep(currentStep, nextNoteTime, beatDurSec);
    advanceStep(beatDurSec);
  }
}

function scheduleStep(stepIdx, time, beatDurSec) {
  playStepAt(stepIdx, time, beatDurSec);

  if (FEEL.cueBeep && steps[stepIdx] && steps[stepIdx].cue) {
    scheduleClick(time, true, 0.10);
  }

  // UI highlight is best-effort (visual only)
  const delayMs = Math.max(0, (time - Tone.now()) * 1000);
  setTimeout(() => {
    if (!isPlaying) return;
    document.querySelectorAll('.segment').forEach(s => s.classList.remove('playing'));
    const seg = document.getElementById(`seg-${stepIdx}`);
    if (seg) seg.classList.add('playing');
  }, delayMs);
}

function advanceStep(beatDurSec) {
  const bpm = parseFloat(document.getElementById('bpm').value || "80");
  const stepSec = steps[currentStep].val * (60 / Math.max(30, Math.min(220, bpm)));

  currentStep++;

  if (currentStep >= steps.length) {
    currentStep = 0;
    barIndex++;

    if (document.getElementById('chk-auto').checked) {
      const nextChord = getChordForBar(barIndex);
      if (nextChord) setChord(nextChord, true);
    }
    updateChordLoopCurrent();
  }

  nextNoteTime += stepSec;
}

// STEP ENGINE:
// - "B√ôM": bass string (c.b)
// - "1": next string below bass
// - "2": next string below "1"
// - "3": sweep remaining strings (downstroke) theo ƒë√∫ng m√¥ t·∫£ video
// - "CH√ÅT": GI·ªÆ NGUY√äN B·∫¢N (nh∆∞ code c·ªßa b·∫°n): qu·∫πt l√™n 1-2-3, c√≥ release ng·∫Øn
function playStepAt(idx, time, beatDurSec) {
  if (!guitar) return;

  const s = steps[idx];
  const c = CHORDS[currentChord];

  const getN = (str) => {
    let i = 6 - str;
    if (i < 0 || i >= TUNING.length) return null;
    let f = c.f[i];
    return (f === -1) ? null : (TUNING[i] + f);
  };

  const beatStart = (stepBeatStarts && stepBeatStarts[idx] != null)
    ? stepBeatStarts[idx]
    : steps.slice(0, idx).reduce((a, x) => a + x.val, 0);

  const beatPos = (beatStart % 4 + 4) % 4; // 0..4
  const strong = (beatPos === 0 || beatPos === 2);
  const back  = (beatPos === 1 || beatPos === 3);

  const stepSec = s.val * beatDurSec;
  const durBass = Math.max(0.06, stepSec * 0.85);
  const durFill = Math.max(0.04, Math.min(0.12, stepSec * 0.55));

  // micro timing feel
  const human = ((Math.random() * 2 - 1) * (FEEL.humanizeMs / 1000));
  const groove = (s.type === "bass")
    ? (-FEEL.grooveMs * 0.25 / 1000)
    : (FEEL.grooveMs / 1000);

  const t0 = Math.max(time + human + groove, Tone.now() + 0.003);

  // dynamics
  const accent = clamp(FEEL.accentPct / 100, 0, 0.5);
  const dynVar = clamp(FEEL.dynPct / 100, 0, 0.25);

  function g(base, kind) {
    let out = base;
    if (kind === "bass") out *= strong ? (1 + accent) : (1 + accent * 0.10);
    if (kind === "fill") out *= back ? (1 + accent * 0.55) : (1 - accent * 0.05);
    if (kind === "chat") out *= back ? (1 + accent * 0.35) : (1 - accent * 0.05);
    out *= (1 + (Math.random() * 2 - 1) * dynVar);
    return clamp(out, 0.05, 2.0);
  }

  const bassStr = c.b;
  let dispStr = "";

  try {
    if (s.label === "B√ôM") {
      const n = getN(bassStr);
      safePlaySingle(n, t0, durBass, g(1.00, "bass"));
      dispStr = `B√ôM D√ÇY ${bassStr}`;
    } else if (s.label === "B√ôM+1") {
      // B√ôM+1: c·ªë g·∫Øng ƒë√°nh "d√¢y k·ªÅ" ƒë·ªÉ ra c·∫£m gi√°c alternate bass.
      // M·ªôt s·ªë h·ª£p √¢m (C, Dm, D...) th∆∞·ªùng mute d√¢y k·ªÅ theo th·∫ø b·∫•m c∆° b·∫£n,
      // n√™n ta ch·ªçn d√¢y g·∫ßn nh·∫•t c√≤n ph√°t ra n·ªët ƒë·ªÉ tr√°nh "m·∫•t ti·∫øng".
      const candidates = [bassStr + 1, bassStr - 1, bassStr + 2, bassStr - 2, bassStr + 3, bassStr - 3]
        .filter(st => st >= 1 && st <= 6);
      let alt = null;
      for (const st of candidates) {
        const n0 = getN(st);
        if (n0 != null) { alt = st; break; }
      }
      if (alt != null) {
        safePlaySingle(getN(alt), t0, durBass, g(0.92, "bass"));
        dispStr = `B√ôM D√ÇY ${alt}`;
      } else {
        // fallback: n·∫øu kh√¥ng t√¨m ƒë∆∞·ª£c d√¢y h·ª£p l·ªá, ƒë√°nh l·∫°i bass ch√≠nh
        const n = getN(bassStr);
        safePlaySingle(n, t0, durBass, g(0.90, "bass"));
        dispStr = `B√ôM D√ÇY ${bassStr}`;
      }
    } else if (s.label === "1") {
      const st = Math.max(1, bassStr - 1);
      safePlaySingle(getN(st), t0, durFill, g(0.70, "fill"));
      dispStr = `D√ÇY ${st}`;
    } else if (s.label === "2") {
      const st = Math.max(1, bassStr - 2);
      safePlaySingle(getN(st), t0, durFill, g(0.68, "fill"));
      dispStr = `D√ÇY ${st}`;
    } else if (s.label === "3") {
      let strs = [];
      for (let st = bassStr - 3; st >= 1; st--) strs.push(st);
      if (strs.length === 0) strs = [3,2,1].filter(x => x <= bassStr);

      const gap = 0.014; // strum spread
      const gg = g(0.78, "fill");
      strs.forEach((st, i) => {
        const n = getN(st);
        if (n) safePlaySingle(n, t0 + i * gap, Math.max(0.05, durFill), gg);
      });
      dispStr = `VU·ªêT ${strs.join('-')}`;
    } else if (s.label === "CH√ÅT") {
      const gap = 0.010;
      const gg = g(0.90, "chat");
      [1,2,3].forEach((st, i) => {
        const n = getN(st);
        if (n) safePlaySingle(n, t0 + i * gap, 0.10, gg, 0.05);
      });
      dispStr = "CH√ÅT (L√äN)";
    }
  } catch (err) {
    console.warn("Skip step error", err);
  }

  // UI-only string display
  const chordSnap = currentChord;
  const delayMs = Math.max(0, (t0 - Tone.now()) * 1000);
  setTimeout(() => {
    if (isPlaying) document.getElementById('str-display').innerText = dispStr;
      const cd = document.getElementById('chord-display');
      if (cd) cd.innerText = chordSnap || currentChord || '---';
  }, delayMs);
}

// SAFE PLAY HELPERS
function safePlaySingle(n, time, dur, gain, release) {
  if (n === null || n === undefined) return;
  try {
    const opts = { duration: dur, gain: gain };
    if (release) opts.release = release;
    guitar.play(n, time, opts);
  } catch (e) {}
}



// === INIT UI (kh√¥ng c·∫ßn b·∫≠t ƒë√†n) ===
try { renderTimeline(); } catch(e) {}
try { renderChordLoop(); } catch(e) {}
try { renderChordBank(); } catch(e) {}
try { updateChordLoopCurrent(); } catch(e) {}
try {
  const cd = document.getElementById('chord-display');
  if (cd) cd.innerText = currentChord || "Am";
} catch(e) {}


// === PH√çM T·∫ÆT (PC): SPACE ƒë·ªÉ Play/Stop ===
document.addEventListener('keydown', (e) => {
  if (e.code !== 'Space' || e.repeat) return;

  const tag = (e.target && e.target.tagName) ? e.target.tagName.toUpperCase() : "";
  const editable = (e.target && (e.target.isContentEditable || tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT"));
  if (editable) return;

  e.preventDefault();
  try { togglePlay(); } catch(err) {}
});

window.setChord = function(c, fromAuto = false) {
  if (!c || !CHORDS[c]) return;
  currentChord = c;
  const cd = document.getElementById("chord-display");
  if (cd) cd.innerText = currentChord;

  // ch·ªâ ƒë·ªìng b·ªô active/selected, kh√¥ng ph√° l·ª±a ch·ªçn c·ªßa ng∆∞·ªùi d√πng khi auto ƒë·ªïi h·ª£p √¢m
  if (typeof refreshChordButtons === "function") refreshChordButtons();
};
</script>
</body>
</html>
