<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tay Guitar Ảo (Nhậu Mode) — Click hợp âm là đệm</title>

  <!-- WebAudioFont core (realistic sample-based instruments) -->
  <script src="https://surikov.github.io/webaudiofont/npm/dist/WebAudioFontPlayer.js"></script>

  <style>
    :root { color-scheme: dark; --bg:#0b0f19; --card:#121a2b; --muted:#9fb0d0; --text:#e9eefc; --btn:#2a3b63; --btn2:#1e2a46; --line:#26324f; --accent:#7aa7ff; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 18px; }
    h1 { margin: 0 0 8px; font-size: 20px; font-weight: 800; letter-spacing: .2px; }
    p { margin: 6px 0 0; color: var(--muted); line-height: 1.45; }
    .grid { display:grid; grid-template-columns: 420px 1fr; gap: 14px; align-items:start; }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }

    .card { background: var(--card); border: 1px solid rgba(255,255,255,.08); border-radius: 14px; padding: 14px; }
    .row { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .spacer { height: 10px; }
    .pill { display:inline-flex; gap:8px; align-items:center; padding: 6px 10px; border-radius: 999px; border: 1px solid rgba(255,255,255,.12); color: var(--muted); font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .btn {
      appearance:none; border: 1px solid rgba(255,255,255,.12);
      background: var(--btn); color: var(--text);
      padding: 10px 12px; border-radius: 12px; cursor: pointer;
      font-weight: 700; letter-spacing: .2px;
    }
    .btn:hover { background: #324879; }
    .btn.secondary { background: var(--btn2); }
    .btn.danger { background: #4a1f2a; }
    .btn:disabled { opacity: .55; cursor:not-allowed; }
    select, input[type="number"], textarea {
      background: #0f1627; color: var(--text);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 12px;
      padding: 10px 12px;
      outline: none;
    }
    textarea { width: 100%; height: 520px; resize: vertical; line-height: 1.35; }
    label { display:block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
    input[type="range"] { width: 240px; }
    hr { border: none; border-top: 1px solid rgba(255,255,255,.10); margin: 12px 0; }

    /* Rendered song */
    .song { font-size: 16px; line-height: 1.55; }
    .line { padding: 6px 0; border-bottom: 1px dashed rgba(255,255,255,.06); }
    .line:last-child { border-bottom: none; }
    .sectionTitle { margin-top: 12px; font-weight: 800; color: #cfe0ff; }
    .metaRow { display:flex; gap:10px; flex-wrap:wrap; }
    .chord {
      display:inline-flex; align-items:center; justify-content:center;
      margin: 0 4px;
      padding: 3px 10px;
      border-radius: 999px;
      border: 1px solid rgba(122,167,255,.55);
      background: rgba(122,167,255,.12);
      color: #dbe8ff;
      font-weight: 800;
      cursor: pointer;
      user-select: none;
      transform: translateY(-1px);
    }
    .chord:hover { background: rgba(122,167,255,.18); }
    .chord.active { background: rgba(122,167,255,.28); border-color: rgba(122,167,255,.9); box-shadow: 0 0 0 2px rgba(122,167,255,.15) inset; }
    .hint { font-size: 12px; color: var(--muted); }
    .kbd { border: 1px solid rgba(255,255,255,.14); border-bottom-width: 2px; border-radius: 8px; padding: 2px 6px; background: rgba(255,255,255,.06); font-size: 12px; }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>Tay Guitar Ảo (Nhậu Mode) — Click hợp âm là đệm “giống người”</h1>
    <p>
      Dán input dạng <span class="mono">[Chord]</span> như bạn đưa. Người hát tới đâu, bạn bấm ngay hợp âm trong lời: app sẽ đệm 1 ô bolero (bass + chát).
      Nếu bật <b>Hold</b>, app sẽ lặp bolero nền và đổi hợp âm mượt ở đầu ô nhịp kế tiếp.
    </p>

    <div class="grid">
      <!-- LEFT: Input + controls -->
      <div class="card">
        <div class="row">
          <button id="btnEnable" class="btn">Bật âm thanh</button>
          <span class="pill">Audio: <span id="audioState" class="mono">OFF</span></span>
          <span class="pill">Preset: <span id="presetState" class="mono">chưa nạp</span></span>
        </div>

        <div class="spacer"></div>

        <div class="row">
          <div>
            <label>Guitar preset</label>
            <select id="presetSel">
              <option value="steel_lk">Acoustic Steel — LK (đậm, thật)</option>
              <option value="steel_std">Acoustic Steel — Standard</option>
              <option value="nylon_lk">Acoustic Nylon — LK (mềm, bolero)</option>
              <option value="elec_clean">Electric Clean — Aspirin</option>
              <option value="elec_jazz">Electric Jazz — Aspirin</option>
              <option value="elec_muted">Electric Muted — Aspirin (cộc)</option>
            </select>
          </div>
          <div style="margin-top:18px">
            <button id="btnLoadPreset" class="btn secondary" disabled>Nạp preset</button>
          </div>
        </div>

        <div class="spacer"></div>

        <div class="row">
          <div>
            <label>BPM</label>
            <input id="bpm" type="range" min="55" max="200" value="92" />
            <span class="pill"><span id="bpmVal" class="mono">92</span> BPM</span>
          </div>

          <div>
            <label>Tap tempo</label>
            <button id="btnTap" class="btn secondary" disabled>Tap</button>
            <span class="pill">Hold: <span id="holdState" class="mono">OFF</span></span>
          </div>
        </div>

        <div class="row">
          <button id="btnHold" class="btn secondary" disabled>Bật Hold (đệm nền)</button>
          <button id="btnStop" class="btn danger" disabled>Stop (tắt tiếng)</button>

          <label class="pill" style="cursor:pointer">
            <input id="metro" type="checkbox" style="transform:scale(1.05)" />
            Metronome
          </label>
        </div>

        <hr />

        <div class="row">
          <div style="flex:1; min-width: 260px">
            <label>Input (dán bài vào đây)</label>
            <textarea id="input"></textarea>
          </div>
        </div>

        <div class="row">
          <button id="btnRender" class="btn secondary" disabled>Render + Bấm hợp âm để đệm</button>
          <button id="btnExample" class="btn secondary">Nạp ví dụ (tone Dm, bolero)</button>
        </div>

        <p class="hint">
          Mẹo nhậu: bật <b>Hold</b> để app quạt nền; khi đổi hợp âm chỉ cần chạm chord tiếp theo, app sẽ “ăn” vào đầu ô nhịp kế tiếp.
          Phím tắt: <span class="kbd">Space</span> = Stop.
        </p>
      </div>

      <!-- RIGHT: Rendered song -->
      <div class="card">
        <div class="metaRow">
          <span class="pill">Tone: <span id="metaTone" class="mono">—</span></span>
          <span class="pill">Điệu: <span id="metaStyle" class="mono">—</span></span>
          <span class="pill">Current: <span id="nowChord" class="mono">—</span></span>
          <span class="pill">Next (pending): <span id="pendingChord" class="mono">—</span></span>
        </div>

        <div class="spacer"></div>
        <div id="song" class="song">
          <p class="muted">Bấm “Render + Bấm hợp âm để đệm” để hiện lời + hợp âm clickable.</p>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ------------------------------
  // Instrument catalog (dynamic load)
  // ------------------------------
  const BASE = "https://surikov.github.io/webaudiofontdata/sound/";
  const INSTRUMENTS = {
    steel_lk:   { label:"Acoustic Steel — LK",     file:"0250_LK_AcousticSteel_SF2_file.js", varName:"_tone_0250_LK_AcousticSteel_SF2_file" },
    steel_std:  { label:"Acoustic Steel — Std",    file:"0250_Acoustic_Guitar_sf2_file.js",  varName:"_tone_0250_Acoustic_Guitar_sf2_file" },
    nylon_lk:   { label:"Acoustic Nylon — LK",     file:"0240_LK_Godin_Nylon_SF2_file.js",   varName:"_tone_0240_LK_Godin_Nylon_SF2_file" },
    elec_clean: { label:"Electric Clean — Aspirin",file:"0270_Aspirin_sf2_file.js",          varName:"_tone_0270_Aspirin_sf2_file" },
    elec_jazz:  { label:"Electric Jazz — Aspirin", file:"0260_Aspirin_sf2_file.js",          varName:"_tone_0260_Aspirin_sf2_file" },
    elec_muted: { label:"Electric Muted — Aspirin",file:"0280_Aspirin_sf2_file.js",          varName:"_tone_0280_Aspirin_sf2_file" },
  };

  // ------------------------------
  // DOM
  // ------------------------------
  const $ = (s) => document.querySelector(s);
  const el = {
    btnEnable: $("#btnEnable"),
    btnLoadPreset: $("#btnLoadPreset"),
    presetSel: $("#presetSel"),
    presetState: $("#presetState"),
    audioState: $("#audioState"),

    bpm: $("#bpm"),
    bpmVal: $("#bpmVal"),
    btnTap: $("#btnTap"),
    btnHold: $("#btnHold"),
    holdState: $("#holdState"),
    btnStop: $("#btnStop"),
    metro: $("#metro"),

    input: $("#input"),
    btnRender: $("#btnRender"),
    btnExample: $("#btnExample"),

    metaTone: $("#metaTone"),
    metaStyle: $("#metaStyle"),
    nowChord: $("#nowChord"),
    pendingChord: $("#pendingChord"),
    song: $("#song"),
  };

  // ------------------------------
  // Audio engine (WebAudioFont + small mix chain)
  // ------------------------------
  const AudioContextFunc = window.AudioContext || window.webkitAudioContext;
  let ctx = null;
  let player = null;
  let preset = null;

  let masterGain, compressor, hp, lp, convolver, wetGain, dryGain, outGain;

  function makeImpulseResponse(context, seconds = 1.2, decay = 3.6) {
    const rate = context.sampleRate;
    const length = Math.max(1, Math.floor(rate * seconds));
    const ir = context.createBuffer(2, length, rate);
    for (let ch = 0; ch < 2; ch++) {
      const data = ir.getChannelData(ch);
      for (let i = 0; i < length; i++) {
        const t = i / length;
        const env = Math.pow(1 - t, decay);
        data[i] = (Math.random() * 2 - 1) * env;
      }
    }
    return ir;
  }

  async function ensureAudio() {
    if (!ctx) {
      ctx = new AudioContextFunc();
      player = new WebAudioFontPlayer();

      masterGain = ctx.createGain();
      masterGain.gain.value = 0.95;

      compressor = ctx.createDynamicsCompressor();
      compressor.threshold.value = -22;
      compressor.knee.value = 18;
      compressor.ratio.value = 3.0;
      compressor.attack.value = 0.008;
      compressor.release.value = 0.18;

      hp = ctx.createBiquadFilter();
      hp.type = "highpass";
      hp.frequency.value = 80;
      hp.Q.value = 0.7;

      lp = ctx.createBiquadFilter();
      lp.type = "lowpass";
      lp.frequency.value = 9000;
      lp.Q.value = 0.7;

      convolver = ctx.createConvolver();
      convolver.buffer = makeImpulseResponse(ctx);

      wetGain = ctx.createGain();
      wetGain.gain.value = 0.18;

      dryGain = ctx.createGain();
      dryGain.gain.value = 1.0;

      outGain = ctx.createGain();
      outGain.gain.value = 0.95;

      masterGain.connect(compressor);
      compressor.connect(hp);
      hp.connect(lp);

      lp.connect(dryGain);
      lp.connect(convolver);
      convolver.connect(wetGain);

      dryGain.connect(outGain);
      wetGain.connect(outGain);
      outGain.connect(ctx.destination);
    }
    if (ctx.state !== "running") await ctx.resume();

    el.audioState.textContent = "ON";
    el.btnLoadPreset.disabled = false;
    el.btnRender.disabled = false;
    el.btnTap.disabled = false;
    el.btnHold.disabled = false;
    el.btnStop.disabled = false;
  }

  function loadPresetByKey(key) {
    if (!ctx || !player) return;
    const instr = INSTRUMENTS[key] || INSTRUMENTS.steel_lk;
    el.presetState.textContent = "loading...";
    const url = BASE + instr.file;
    player.loader.startLoad(ctx, url, instr.varName);
    player.loader.waitLoad(() => {
      preset = window[instr.varName];
      player.loader.decodeAfterLoading(ctx, instr.varName);
      el.presetState.textContent = instr.label;
    });
  }

  // ------------------------------
  // Tempo + metronome
  // ------------------------------
  function secPerBeat() { return 60 / Number(el.bpm.value); }
  function barDur() { return secPerBeat() * 4; } // bolero/4-4
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  function randSigned(){ return (Math.random()*2 - 1); }

  // Tap tempo
  let tapTimes = [];
  el.btnTap.addEventListener("click", () => {
    const t = performance.now();
    tapTimes.push(t);
    if (tapTimes.length > 6) tapTimes.shift();
    if (tapTimes.length >= 3) {
      let sum = 0;
      for (let i = 1; i < tapTimes.length; i++) sum += (tapTimes[i] - tapTimes[i-1]);
      const avgMs = sum / (tapTimes.length - 1);
      const bpm = clamp(Math.round(60000 / avgMs), 55, 200);
      el.bpm.value = String(bpm);
      el.bpmVal.textContent = String(bpm);
    }
  });

  // Metronome (simple click)
  let metroTimer = null;
  function metroClick(when, accent=false) {
    if (!ctx) return;
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = "square";
    o.frequency.setValueAtTime(accent ? 1650 : 1300, when);
    g.gain.setValueAtTime(0.0001, when);
    g.gain.linearRampToValueAtTime(accent ? 0.22 : 0.16, when + 0.002);
    g.gain.exponentialRampToValueAtTime(0.0001, when + 0.04);
    o.connect(g);
    g.connect(ctx.destination);
    o.start(when);
    o.stop(when + 0.06);
  }
  function startMetronome() {
    stopMetronome();
    let next = ctx.currentTime + 0.02;
    let beat = 0;
    const lookahead = 0.12;
    const tick = () => {
      const spb = secPerBeat();
      while (next < ctx.currentTime + lookahead) {
        metroClick(next, (beat % 4 === 0));
        next += spb;
        beat++;
      }
      metroTimer = setTimeout(tick, 25);
    };
    tick();
  }
  function stopMetronome() {
    if (metroTimer) clearTimeout(metroTimer);
    metroTimer = null;
  }

  // ------------------------------
  // Chord parsing + voicing (generic)
  // ------------------------------
  const NOTE = { C:0, D:2, E:4, F:5, G:7, A:9, B:11 };
  function parseChordSymbol(symRaw) {
    const sym = symRaw.trim();

    // Handle slash chords: Dm/A
    let main = sym, slash = null;
    const slashIdx = sym.indexOf("/");
    if (slashIdx >= 0) {
      main = sym.slice(0, slashIdx).trim();
      slash = sym.slice(slashIdx + 1).trim();
    }

    // Root: letter + optional #/b
    const m = main.match(/^([A-G])([#b]?)(.*)$/);
    if (!m) return { ok:false, sym };

    let root = m[1];
    let acc = m[2] || "";
    let qual = (m[3] || "").trim();

    // Normalize "maj" cases
    // Examples: Dm, Dm7, D7, Dmaj7, DΔ7, Dsus4, Ddim, Daug, Dadd9, etc.
    qual = qual.replace("Δ", "maj");

    // Determine quality
    let triad = "maj";
    let add7 = null; // "min7" or "maj7"
    let add9 = false;
    let sus = null; // 2 or 4
    let dim = false, aug = false;

    // sus/add
    if (/sus2/i.test(qual)) sus = 2;
    if (/sus4/i.test(qual)) sus = 4;
    if (/add9/i.test(qual)) add9 = true;

    // dim/aug
    if (/dim|o/i.test(qual)) dim = true;
    if (/aug|\+/i.test(qual)) aug = true;

    // minor vs major (but keep maj7 distinct)
    // If starts with "m" and not "maj"
    if (/^m(?!aj)/i.test(qual)) triad = "min";
    if (/^min/i.test(qual)) triad = "min";

    // 7ths
    if (/maj7/i.test(qual)) add7 = "maj7";
    else if (/m7/i.test(qual)) add7 = "min7"; // minor 7th above root
    else if (/7/.test(qual)) add7 = "min7";   // dominant 7

    // Slash bass note
    let slashSemitone = null;
    if (slash) {
      const sm = slash.match(/^([A-G])([#b]?)$/);
      if (sm) slashSemitone = (NOTE[sm[1]] + (sm[2] === "#" ? 1 : sm[2] === "b" ? -1 : 0) + 12) % 12;
    }

    const rootSemitone = (NOTE[root] + (acc === "#" ? 1 : acc === "b" ? -1 : 0) + 12) % 12;

    return {
      ok:true,
      sym,
      rootSemitone,
      triad,
      sus,
      dim,
      aug,
      add7,
      add9,
      slashSemitone
    };
  }

  function buildVoicing(sym) {
    const c = parseChordSymbol(sym);
    if (!c.ok) return [48, 52, 55, 60]; // fallback C-ish

    // Choose a comfortable "rootMidi" near guitar mid range
    // Base around C3=48; shift down if too high
    let rootMidi = 48 + c.rootSemitone;   // around 48..59
    if (rootMidi > 55) rootMidi -= 12;    // keep near 43..55

    // Triad intervals
    let i3 = 4, i5 = 7;
    if (c.dim) { i3 = 3; i5 = 6; }
    else if (c.aug) { i3 = 4; i5 = 8; }
    else if (c.sus === 2) { i3 = 2; i5 = 7; }
    else if (c.sus === 4) { i3 = 5; i5 = 7; }
    else if (c.triad === "min") { i3 = 3; i5 = 7; }

    const notes = [];
    // Bass note: use slash if present, else root. Clamp to guitar-ish bass.
    let bassMidi;
    if (c.slashSemitone != null) {
      bassMidi = 48 + c.slashSemitone;
      if (bassMidi > 52) bassMidi -= 12;
    } else {
      bassMidi = rootMidi - 12;
    }
    // Guitar lowest is E2=40; clamp bass to 40..52
    bassMidi = clamp(bassMidi, 40, 52);

    notes.push(bassMidi);
    notes.push(rootMidi);
    notes.push(rootMidi + i3);
    notes.push(rootMidi + i5);
    // Add octave for fullness
    notes.push(rootMidi + 12);

    if (c.add7) {
      const i7 = (c.add7 === "maj7") ? 11 : 10;
      notes.push(rootMidi + i7);
      notes.push(rootMidi + 12 + i3); // sweet top note
    }

    if (c.add9) {
      notes.push(rootMidi + 14);
    }

    // Cleanup: unique + sort
    const uniq = Array.from(new Set(notes.map(n => Math.round(n)))).sort((a,b)=>a-b);

    // Keep within a reasonable range; if too many notes, take bass + 4 highs
    if (uniq.length > 6) {
      return [uniq[0], uniq[2], uniq[3], uniq[4], uniq[5], uniq[uniq.length-1]];
    }
    return uniq;
  }

  function bassPitchForChord(sym) {
    const pitches = buildVoicing(sym);
    return pitches[0] ?? 45;
  }

  // ------------------------------
  // Bolero pattern scheduling
  // ------------------------------
  const BOLERO_EVENTS = [
    {t:0.00, type:"bass", v:0.90},
    {t:0.12, type:"down", v:0.55},
    {t:0.25, type:"down", v:0.50},
    {t:0.50, type:"bass", v:0.85},
    {t:0.62, type:"down", v:0.55},
    {t:0.75, type:"down", v:0.50},
  ];

  function scheduleOneBarBolero(chordSym, barStart) {
    if (!ctx || !player || !preset) return;
    const dur = barDur();

    // Humanize parameters
    const jitter = clamp(secPerBeat() * 0.010, 0.003, 0.010); // seconds
    const ring = clamp(dur * 0.92, 1.0, 3.2);

    // Use guitar-ish pitches
    const pitches = buildVoicing(chordSym);
    const bass = bassPitchForChord(chordSym);

    for (const ev of BOLERO_EVENTS) {
      const t = barStart + ev.t * dur + randSigned() * jitter;
      const v = clamp(ev.v + randSigned() * 0.10, 0.25, 0.95);

      if (ev.type === "bass") {
        player.queueWaveTable(ctx, masterGain, preset, t, bass, Math.min(0.55, dur * 0.45), v);
      } else if (ev.type === "down") {
        // queueStrumDown already has internal spread; we still schedule in time slots
        player.queueStrumDown(ctx, masterGain, preset, t, pitches, ring, v);
      }
    }
  }

  // ------------------------------
  // Hold mode: loop bars + quantized chord changes
  // ------------------------------
  let holdOn = false;
  let holding = false;
  let currentChord = null;
  let pendingChord = null;

  let schedTimer = null;
  let nextBarTime = 0;

  function setNowChord(sym) {
    currentChord = sym;
    el.nowChord.textContent = sym || "—";
  }
  function setPendingChord(sym) {
    pendingChord = sym;
    el.pendingChord.textContent = sym || "—";
  }

  function startHoldLoop(initialChord) {
    if (!ctx || !preset) return;
    holding = true;
    setNowChord(initialChord);
    setPendingChord(null);

    // start a little ahead
    nextBarTime = ctx.currentTime + 0.08;

    const lookahead = 0.22;
    const tick = () => {
      if (!holding) return;

      while (nextBarTime < ctx.currentTime + lookahead) {
        // If user clicked a new chord while holding, switch at bar boundary
        if (pendingChord) {
          setNowChord(pendingChord);
          setPendingChord(null);
        }
        scheduleOneBarBolero(currentChord, nextBarTime);
        nextBarTime += barDur();
      }
      schedTimer = setTimeout(tick, 25);
    };
    tick();
  }

  function stopAll() {
    holding = false;
    holdOn = false;
    el.holdState.textContent = "OFF";
    el.btnHold.textContent = "Bật Hold (đệm nền)";

    if (schedTimer) clearTimeout(schedTimer);
    schedTimer = null;

    if (player && ctx) player.cancelQueue(ctx);
    setNowChord(null);
    setPendingChord(null);

    if (el.metro.checked) {
      el.metro.checked = false;
      stopMetronome();
    }
  }

  // ------------------------------
  // Rendering chord sheet to clickable UI
  // ------------------------------
  function parseMetadata(text) {
    // Try to find Tone: and Điệu:
    const tone = (text.match(/^\s*Tone:\s*(.+)\s*$/mi) || [])[1]?.trim() || "—";
    const style = (text.match(/^\s*Điệu:\s*(.+)\s*$/mi) || [])[1]?.trim() || "—";
    return { tone, style };
  }

  function isSectionTitle(line) {
    return /^\s*(Intro:|ĐK:|DK:|Điệp khúc:|Chorus:|Verse\s*\d+|Bridge:|\d+\.)/i.test(line.trim());
  }

  function renderSong(text) {
    const { tone, style } = parseMetadata(text);
    el.metaTone.textContent = tone;
    el.metaStyle.textContent = style;

    const lines = text.replace(/\r/g, "").split("\n");
    const container = document.createElement("div");

    for (const rawLine of lines) {
      const line = rawLine.trimEnd();

      if (!line.trim()) {
        const spacer = document.createElement("div");
        spacer.className = "line";
        spacer.style.borderBottom = "none";
        spacer.innerHTML = "&nbsp;";
        container.appendChild(spacer);
        continue;
      }

      // Skip metadata lines from rendering body
      if (/^\s*Tone\s*:/i.test(line) || /^\s*Điệu\s*:/i.test(line)) continue;

      const div = document.createElement("div");
      div.className = "line";

      if (isSectionTitle(line)) {
        const t = document.createElement("div");
        t.className = "sectionTitle";
        t.textContent = line;
        div.appendChild(t);
        container.appendChild(div);
        continue;
      }

      // Tokenize [Chord]
      const parts = [];
      const re = /\[([^\]]+)\]/g;
      let lastIdx = 0;
      let m;
      while ((m = re.exec(line)) !== null) {
        const before = line.slice(lastIdx, m.index);
        if (before) parts.push({ type:"text", value: before });
        parts.push({ type:"chord", value: m[1].trim() });
        lastIdx = m.index + m[0].length;
      }
      const tail = line.slice(lastIdx);
      if (tail) parts.push({ type:"text", value: tail });

      for (const p of parts) {
        if (p.type === "text") {
          div.appendChild(document.createTextNode(p.value));
        } else {
          const sp = document.createElement("span");
          sp.className = "chord";
          sp.textContent = p.value;
          sp.dataset.chord = p.value;
          sp.title = "Bấm để đệm: " + p.value;

          sp.addEventListener("click", async (e) => {
            await ensureAudio();
            if (!preset) loadPresetByKey(el.presetSel.value);

            // UI active state
            document.querySelectorAll(".chord.active").forEach(x => x.classList.remove("active"));
            sp.classList.add("active");

            // If hold mode ON: change at next bar boundary
            if (holdOn) {
              if (!holding) {
                // start loop immediately with chosen chord
                setNowChord(p.value);
                startHoldLoop(p.value);
              } else {
                setPendingChord(p.value);
              }
            } else {
              // One-shot: schedule a single bar right now
              setNowChord(p.value);
              setPendingChord(null);
              const start = ctx.currentTime + 0.02;
              scheduleOneBarBolero(p.value, start);
            }
          });

          div.appendChild(sp);
        }
      }

      container.appendChild(div);
    }

    el.song.innerHTML = "";
    el.song.appendChild(container);
  }

  // ------------------------------
  // Wiring UI
  // ------------------------------
  el.bpm.addEventListener("input", () => {
    el.bpmVal.textContent = el.bpm.value;
    // If holding, keep loop stable; nextBarTime already computed, no need to restart.
    // Metronome needs restart to match BPM precisely.
    if (ctx && el.metro.checked) startMetronome();
  });

  el.btnEnable.addEventListener("click", async () => {
    await ensureAudio();
    // auto-load default preset
    loadPresetByKey(el.presetSel.value);
  });

  el.btnLoadPreset.addEventListener("click", async () => {
    await ensureAudio();
    loadPresetByKey(el.presetSel.value);
  });

  el.presetSel.addEventListener("change", () => {
    if (ctx) loadPresetByKey(el.presetSel.value);
  });

  el.btnRender.addEventListener("click", async () => {
    await ensureAudio();
    renderSong(el.input.value);
  });

  el.btnExample.addEventListener("click", () => {
    el.input.value = EXAMPLE;
    // render immediately if audio already on
    if (ctx) renderSong(el.input.value);
  });

  el.btnHold.addEventListener("click", async () => {
    await ensureAudio();
    holdOn = !holdOn;
    el.holdState.textContent = holdOn ? "ON" : "OFF";
    el.btnHold.textContent = holdOn ? "Tắt Hold (đệm nền)" : "Bật Hold (đệm nền)";

    // If turning off hold, stop loop but keep last chord ready
    if (!holdOn && holding) {
      holding = false;
      if (schedTimer) clearTimeout(schedTimer);
      schedTimer = null;
      setPendingChord(null);
    }
  });

  el.btnStop.addEventListener("click", () => stopAll());

  el.metro.addEventListener("change", async () => {
    await ensureAudio();
    if (el.metro.checked) startMetronome();
    else stopMetronome();
  });

  // Space = stop
  window.addEventListener("keydown", (e) => {
    if (e.code === "Space") {
      e.preventDefault();
      stopAll();
    }
  });

  // Stop on tab hidden (avoid runaway audio)
  document.addEventListener("visibilitychange", () => {
    if (document.hidden) stopAll();
  });

  // ------------------------------
  // Example input (your sample)
  // ------------------------------
  const EXAMPLE =
`Tone: Dm
Điệu: Bolero

Intro: [Dm] [F] [C] [Dm] - [Bb] [C] [F] [Gm] - [Bb] [Am] [Dm] [Am7]

1. Say giấc mộng ban [Dm] đầu yêu [Bb] người thủa mới đôi [F] mươi em [C] đang độ trăng [Dm] tròn
Từng ngày qua [Bb] phố áo [C] em trắng cả đường [F] về
Lá [Gm] thư ướp mộng học [Bb] trò mối [Am]tình xanh như khúc [F] hát. [Dm7] [Am7]

2. Ai đã hẹn với [Dm] thề để [Bb] rồi lỡ mối duyên [F] thơ ra [C] đi chẳng giã [Dm] từ
Ngày em thay [Bb] áo áo [C] hoa pháo đỏ rượu [F] nồng
Có [Gm] ai nát cả cõi [Bb] lòng đứng [Am]nhìn em bước bên [Dm] chồng.

ĐK: Hai mươi [C] năm [Am] cuộc mộng dở [Dm] dang khắc sâu bóng [F] nàng
Lắng trong cung [Dm] đàn [C] em giờ ở [Dm]đâu hẳn vui duyên [F] mới
Hai mươi [C] năm [Am] cuộc rượu còn [Dm]đây uống qua tháng [F] ngày
Cố quên đi [Bb] người say [Am] hoài sầu không [Dm] vơi
Tình duyên ta [F] tiếc [Am] uống thêm ly [Dm]này.

3. [Am7] Ôm giấc mộng lỡ [Dm] làng những [Bb] chiều lắng tiếng mưa [F] rơi đêm [C] say chờ trăng [Dm] tàn
Từng thu thay [Bb] lá, lá [C] rơi đắp mộ cuộc [F] tình
Lá [Gm] bay chất nặng tuổi [Bb] đời nhớ [Am]người ta rót ly [Dm] này.`;

  // Preload example in textarea
  el.input.value = EXAMPLE;
  el.bpmVal.textContent = el.bpm.value;

})();
</script>
</body>
</html>