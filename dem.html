 <!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#0b0b0f" />
  <title>GUITAR NHẬU PRO — 1-file Demo</title>
  <style>
    :root{
      --bg:#0b0b0f;
      --panel:#12121a;
      --panel2:#171724;
      --text:#f2f3f5;
      --muted:#b7bcc7;
      --accent:#ffd54a;
      --good:#46e6a7;
      --bad:#ff6b6b;
      --line:#2a2a3a;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:18px;
      --btn:#222236;
      --btn2:#2a2a44;
      --tap:#1f4aff;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:var(--bg);
      color:var(--text);
      height:100vh;
      overflow:hidden;
    }
    a{color:inherit}
    .app{
      height:100vh;
      display:flex;
      flex-direction:column;
    }
    .hidden{display:none !important}

    /* Setup */
    .setup{
      height:100%;
      display:flex;
      flex-direction:column;
      padding:16px;
      gap:12px;
    }
    .card{
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
    }
    .setup .header{
      padding:14px 14px 10px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .title{
      font-weight:800;
      letter-spacing:.2px;
      line-height:1.15;
    }
    .subtitle{
      color:var(--muted);
      margin-top:6px;
      font-size:13px;
      line-height:1.35;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      background:rgba(255,213,74,.12);
      border:1px solid rgba(255,213,74,.35);
      color:var(--accent);
      font-size:12px;
      white-space:nowrap;
    }
    .form{
      padding:12px 12px 14px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    textarea{
      width:100%;
      min-height:46vh;
      resize:none;
      border-radius:14px;
      border:1px solid var(--line);
      background:var(--panel2);
      color:var(--text);
      padding:12px;
      font-size:14px;
      line-height:1.45;
      outline:none;
    }
    textarea:focus{border-color:rgba(255,213,74,.55)}
    .row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    select, button, input[type="number"]{
      border-radius:14px;
      border:1px solid var(--line);
      background:var(--btn);
      color:var(--text);
      padding:12px 12px;
      font-size:14px;
      outline:none;
    }
    select:focus, button:focus{border-color:rgba(255,213,74,.55)}
    button{
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn-primary{
      background: linear-gradient(180deg, rgba(255,213,74,.22), rgba(255,213,74,.08));
      border:1px solid rgba(255,213,74,.55);
      font-weight:800;
      letter-spacing:.3px;
      flex:1;
      min-width:200px;
      padding:14px 14px;
    }
    .btn-secondary{background:var(--btn2)}
    .hint{
      padding:12px 14px;
      color:var(--muted);
      font-size:12px;
      line-height:1.4;
    }
    .hint code{
      background:rgba(255,255,255,.06);
      padding:2px 6px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.08);
      color:var(--text);
    }

    /* Stage */
    .stage{
      height:100%;
      display:flex;
      flex-direction:column;
      gap:10px;
      padding:10px;
    }
    .prompter{
      flex: 0 0 40%;
      padding:12px 12px;
      overflow:auto;
      scroll-behavior:smooth;
      border-radius:var(--radius);
      background:var(--panel);
      border:1px solid var(--line);
      box-shadow:var(--shadow);
      line-height:1.6;
      font-size:16px;
    }
    .prompter .linegap{display:block; height:10px}
    .cue{
      position:relative;
      font-weight:800;
      color:var(--text);
      padding:1px 3px;
      border-radius:8px;
    }
    .cue[data-state="upcoming"]{
      color:var(--accent);
      background:rgba(255,213,74,.10);
      border:1px dashed rgba(255,213,74,.35);
    }
    .cue[data-state="active"]{
      color:var(--good);
      background:rgba(70,230,167,.10);
      border:1px solid rgba(70,230,167,.35);
    }
    .chordtag{
      font-size:11px;
      color:rgba(255,255,255,.55);
      margin-right:6px;
      vertical-align:super;
      letter-spacing:.2px;
    }

    .dash{
      flex:0 0 10%;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;
      border-radius:var(--radius);
      background:var(--panel);
      border:1px solid var(--line);
      box-shadow:var(--shadow);
    }
    .dash-left{
      display:flex;
      flex-direction:column;
      gap:2px;
      min-width: 55%;
    }
    .dash-title{
      font-weight:800;
      letter-spacing:.2px;
      font-size:14px;
    }
    .dash-sub{
      color:var(--muted);
      font-size:12px;
    }
    .dash-controls{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .btn-mini{
      width:52px;
      height:48px;
      border-radius:16px;
      background:var(--btn2);
      border:1px solid var(--line);
      font-weight:900;
      font-size:18px;
    }
    .bpm{
      min-width:74px;
      text-align:center;
      font-weight:900;
      letter-spacing:.5px;
    }

    .trigger{
      flex: 1 1 50%;
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      text-align:center;
      border-radius:var(--radius);
      background: radial-gradient(1200px 400px at 50% 100%, rgba(31,74,255,.22), rgba(0,0,0,0)),
                  linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border:1px solid rgba(255,255,255,.10);
      box-shadow:var(--shadow);
      position:relative;
      overflow:hidden;
      touch-action: pan-y;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .trigger:active{
      transform: translateY(1px);
      filter: brightness(1.05);
    }
    .now{
      font-size:64px;
      font-weight:1000;
      letter-spacing:1px;
      line-height:1;
      margin: 0 10px;
    }
    .next{
      margin-top:10px;
      color:var(--muted);
      font-size:16px;
    }
    .next strong{color:var(--accent)}
    .status{
      position:absolute;
      top:12px;
      left:12px;
      right:12px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size:12px;
      color:var(--muted);
      opacity:.95;
    }
    .status .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.18);
      backdrop-filter: blur(8px);
    }
    .flash{
      animation: flash .24s ease-in-out 0s 2;
    }
    @keyframes flash{
      0%{box-shadow:var(--shadow)}
      50%{box-shadow: 0 0 0 4px rgba(255,213,74,.18), var(--shadow)}
      100%{box-shadow:var(--shadow)}
    }

    /* small screens */
    @media (max-width:420px){
      .now{font-size:56px}
      .prompter{font-size:15px}
    }
  </style>
</head>
<body>
<div class="app">

  <!-- SETUP SCREEN -->
  <div id="setupScreen" class="setup">
    <div class="card">
      <div class="header">
        <div>
          <div class="title">GUITAR NHẬU PRO — Web Demo (1 file)</div>
          <div class="subtitle">Gõ là hát. Máy giữ nhịp, bạn chỉ đổi hợp âm đúng câu. Có “bắt dính nhịp” để bấm lệch vẫn đều.</div>
        </div>
        <div class="pill" title="MVP: synth giả lập guitar. Nâng cấp: sample thật.">Bolero + Quantize</div>
      </div>
      <div class="form">
        <textarea id="songInput" spellcheck="false"></textarea>

        <div class="row">
          <select id="rhythmSelect" aria-label="Điệu">
            <option value="Bolero">Bolero</option>
            <option value="Slow" disabled>Slow (sắp có)</option>
            <option value="Disco" disabled>Disco (sắp có)</option>
          </select>

          <button id="cleanBtn" class="btn-secondary" type="button">Làm sạch xuống dòng</button>
          <button id="startBtn" class="btn-primary" type="button">LÊN SÂN KHẤU</button>
        </div>

        <div class="hint">
          Mẹo nhập: dùng hợp âm dạng <code>[Dm]</code>, <code>[Bb]</code>, <code>[Am7]</code> đặt ngay trước chữ cần đổi.
          Vuốt trái để undo, giữ lâu để dừng.
        </div>
      </div>
    </div>
  </div>

  <!-- STAGE SCREEN -->
  <div id="stageScreen" class="stage hidden">
    <div id="prompter" class="prompter" aria-label="Lời bài hát"></div>

    <div class="dash">
      <div class="dash-left">
        <div class="dash-title" id="dashTitle">Bolero | Tone: —</div>
        <div class="dash-sub" id="dashSub">Tap: Next | Vuốt trái: Undo | Giữ lâu: Stop</div>
      </div>
      <div class="dash-controls">
        <button class="btn-mini" id="bpmDown" type="button">−</button>
        <div class="bpm" id="bpmLabel">68 BPM</div>
        <button class="btn-mini" id="bpmUp" type="button">+</button>
      </div>
    </div>

    <div id="triggerZone" class="trigger" role="button" aria-label="Trigger Zone">
      <div class="status">
        <div class="badge" id="quantizeBadge">Quantize: 1 ô nhịp</div>
        <div class="badge" id="pendingBadge" style="visibility:hidden;">Đã nhận — chờ đầu nhịp</div>
      </div>
      <div class="now" id="nowChord">—</div>
      <div class="next" id="nextChord">Sắp tới: <strong>—</strong></div>
    </div>
  </div>

</div>

<!-- Tone.js (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/tone@14.8.49/build/Tone.js"></script>

<script>
/* =========================
   Utilities: clean + parse
========================= */
function cleanInput(text){
  text = (text || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");

  // trim end spaces
  let lines = text.split("\n").map(l => l.replace(/[ \t]+$/g, ""));

  // collapse consecutive blank lines
  const out = [];
  let blank = false;
  for (const l of lines){
    const isBlank = l.trim() === "";
    if (isBlank){
      if (!blank) out.push("");
      blank = true;
    } else {
      out.push(l);
      blank = false;
    }
  }
  return out.join("\n").trim() + "\n";
}

function extractMeta(text){
  const meta = { tone: null, rhythm: null };
  const toneMatch = text.match(/^\s*Tone\s*:\s*(.+)\s*$/mi);
  const rhythmMatch = text.match(/^\s*Điệu\s*:\s*(.+)\s*$/mi);
  if (toneMatch) meta.tone = (toneMatch[1] || "").trim();
  if (rhythmMatch) meta.rhythm = (rhythmMatch[1] || "").trim();
  return meta;
}

/**
 * Parse chord tags [Dm] in the whole text.
 * Produces segments: { chord: string|null, text: string }
 * chord applies to the text AFTER that chord marker.
 */
function parseSong(text){
  const meta = extractMeta(text);

  // We keep the full text, but for lyric rendering we remove meta header lines if present.
  // To keep it simple, we do not delete them; they will just appear at top if the user includes them.
  // If you want to hide them, strip those lines here.

  const segments = [];
  let currentChord = null;
  let lastIdx = 0;

  const re = /\[([^\]]+)\]/g;
  let m;
  while ((m = re.exec(text)) !== null){
    const chord = (m[1] || "").trim();
    const before = text.slice(lastIdx, m.index);
    if (before.length > 0){
      segments.push({ chord: currentChord, text: before });
    } else if (segments.length === 0 && currentChord === null){
      // nothing
    }
    currentChord = chord;
    lastIdx = m.index + m[0].length;
  }
  const tail = text.slice(lastIdx);
  if (tail.length > 0){
    segments.push({ chord: currentChord, text: tail });
  } else if (currentChord !== null){
    // chord at end with no lyric => still count as a chord step
    segments.push({ chord: currentChord, text: "" });
  }

  // Build chord steps (each segment with chord != null is a "step")
  const chordSteps = [];
  for (const seg of segments){
    if (seg.chord) chordSteps.push(seg.chord);
  }

  return { meta, segments, chordSteps };
}

/* =========================
   Chord → notes (basic)
========================= */
const NOTE_TO_SEMI = { C:0, D:2, E:4, F:5, G:7, A:9, B:11 };

function chordToMidiNotes(symbol){
  // Handles: Bb, Dm, Am7, Dm7, F, Gm, C, etc.
  // Limited but enough for the provided sample.
  symbol = (symbol || "").trim();
  if (!symbol) return [];

  const parts = symbol.split("/");
  const chordPart = parts[0].trim();

  const mm = chordPart.match(/^([A-G])([b#]?)(.*)$/);
  if (!mm) return [];

  const letter = mm[1];
  const accidental = mm[2] || "";
  const rest = (mm[3] || "").trim();

  let semi = NOTE_TO_SEMI[letter] ?? 0;
  if (accidental === "b") semi -= 1;
  if (accidental === "#") semi += 1;
  semi = (semi + 12) % 12;

  // quality
  const isMinor = /(^m(?!aj))|(\bm(?!aj))/i.test(rest); // "m" but not "maj"
  const isMaj7  = /maj7/i.test(rest);
  const has7    = /7/.test(rest);

  let triad;
  if (isMinor) triad = [0, 3, 7];
  else triad = [0, 4, 7];

  const intervals = [...triad];
  if (has7){
    if (isMaj7) intervals.push(11);
    else intervals.push(10);
  }

  // Choose a guitar-ish voicing around octave 3-4
  // Root base at C3 (48) + semi, then lift to keep chords not too low
  let rootMidi = 48 + semi;
  if (rootMidi < 50) rootMidi += 12;

  // Build notes: root + 12 (to avoid muddy), plus others
  const mids = intervals.map(i => rootMidi + i + 12);

  // Add an extra root on top for fullness
  mids.push(rootMidi + 24);

  // Sort and dedupe
  const unique = Array.from(new Set(mids)).sort((a,b)=>a-b);
  return unique;
}

function chordBassMidi(symbol, variant="root"){
  symbol = (symbol || "").trim();
  const mm = symbol.match(/^([A-G])([b#]?)/);
  if (!mm) return 38; // D2-ish fallback
  let semi = NOTE_TO_SEMI[mm[1]] ?? 0;
  if (mm[2] === "b") semi -= 1;
  if (mm[2] === "#") semi += 1;
  semi = (semi + 12) % 12;

  // Root around octave 2
  let rootMidi = 36 + semi; // C2 = 36
  // Keep in reasonable range
  if (rootMidi < 36) rootMidi += 12;
  if (rootMidi > 47) rootMidi -= 12;

  if (variant === "fifth"){
    return rootMidi + 7;
  }
  return rootMidi;
}

/* =========================
   Audio Engine (Tone.js)
========================= */
const AudioEngine = (() => {
  let started = false;
  let chordSynth = null;
  let bassSynth = null;
  let seq = null;
  let barWatcherId = null;

  function ensure(){
    if (started) return;

    // Poly pluck for chord strums
    chordSynth = new Tone.PolySynth(Tone.PluckSynth, {
      polyphony: 8,
      options: {
        attackNoise: 1,
        dampening: 4000,
        resonance: 0.92
      }
    }).toDestination();
    chordSynth.volume.value = -10;

    // Bass synth
    bassSynth = new Tone.MonoSynth({
      oscillator: { type: "triangle" },
      envelope: { attack: 0.01, decay: 0.18, sustain: 0.0, release: 0.16 },
      filterEnvelope: { attack: 0.01, decay: 0.10, sustain: 0.0, release: 0.12, baseFrequency: 120, octaves: 2.2 }
    }).toDestination();
    bassSynth.volume.value = -8;

    started = true;
  }

  function setBpm(bpm){
    Tone.Transport.bpm.value = Math.max(40, Math.min(140, bpm));
  }

  function playBolero(getChordSymbol){
    // 8-step per bar (8n). Pattern: Bass -> Treble -> Treble -> Bass -> Treble -> Treble
    // steps: 0 bass(root), 2 strum, 3 strum, 4 bass(fifth), 6 strum, 7 strum
    if (seq) seq.dispose();

    seq = new Tone.Sequence((time, step) => {
      const chord = getChordSymbol();
      if (!chord) return;

      if (step === 0){
        const m = chordBassMidi(chord, "root");
        bassSynth.triggerAttackRelease(Tone.Frequency(m, "midi"), "8n", time, 0.9);
      }
      if (step === 4){
        const m = chordBassMidi(chord, "fifth");
        bassSynth.triggerAttackRelease(Tone.Frequency(m, "midi"), "8n", time, 0.85);
      }

      if (step === 2 || step === 3 || step === 6 || step === 7){
        const mids = chordToMidiNotes(chord);
        const notes = mids.map(m => Tone.Frequency(m, "midi").toNote());

        const strumDelay = 0.015;
        notes.forEach((n, i) => {
          chordSynth.triggerAttackRelease(n, "16n", time + i * strumDelay, 0.7);
        });
      }
    }, [0,1,2,3,4,5,6,7], "8n");

    seq.loop = true;
    seq.start(0);
  }

  function scheduleBarWatcher(onBar){
    if (barWatcherId != null){
      Tone.Transport.clear(barWatcherId);
      barWatcherId = null;
    }
    barWatcherId = Tone.Transport.scheduleRepeat((time) => {
      onBar(time);
    }, "1m");
  }

  async function start(){
    await Tone.start();
    ensure();
  }

  function stopAll(){
    try{
      Tone.Transport.stop();
      Tone.Transport.cancel(0);
    }catch(e){}
    if (seq){ seq.dispose(); seq = null; }
    if (barWatcherId != null){
      try{ Tone.Transport.clear(barWatcherId); }catch(e){}
      barWatcherId = null;
    }
  }

  function outro(chord){
    if (!started || !chordSynth) return;
    const mids = chordToMidiNotes(chord || "Dm");
    const notes = mids.map(m => Tone.Frequency(m, "midi").toNote());
    const t = Tone.now();
    const strumDelay = 0.02;
    notes.forEach((n,i) => chordSynth.triggerAttackRelease(n, "8n", t + i*strumDelay, 0.85));
  }

  return { start, setBpm, playBolero, scheduleBarWatcher, stopAll, outro };
})();

/* =========================
   App State + UI
========================= */
const els = {
  setupScreen: document.getElementById("setupScreen"),
  stageScreen: document.getElementById("stageScreen"),
  songInput: document.getElementById("songInput"),
  rhythmSelect: document.getElementById("rhythmSelect"),
  cleanBtn: document.getElementById("cleanBtn"),
  startBtn: document.getElementById("startBtn"),

  prompter: document.getElementById("prompter"),
  dashTitle: document.getElementById("dashTitle"),
  dashSub: document.getElementById("dashSub"),
  bpmDown: document.getElementById("bpmDown"),
  bpmUp: document.getElementById("bpmUp"),
  bpmLabel: document.getElementById("bpmLabel"),

  triggerZone: document.getElementById("triggerZone"),
  nowChord: document.getElementById("nowChord"),
  nextChord: document.getElementById("nextChord"),
  pendingBadge: document.getElementById("pendingBadge")
};

const state = {
  isPlaying: false,
  bpm: 68,
  rhythm: "Bolero",
  tone: "Dm",

  segments: [],
  chordSteps: [],
  cueEls: [],

  activeStep: 0,
  pendingStep: null,

  // gesture
  pressTimer: null,
  pointerDownAt: null
};

function showSetup(){
  state.isPlaying = false;
  els.stageScreen.classList.add("hidden");
  els.setupScreen.classList.remove("hidden");
}

function showStage(){
  els.setupScreen.classList.add("hidden");
  els.stageScreen.classList.remove("hidden");
}

function setPendingUI(on){
  els.pendingBadge.style.visibility = on ? "visible" : "hidden";
  if (on){
    els.triggerZone.classList.add("flash");
    setTimeout(()=>els.triggerZone.classList.remove("flash"), 700);
  }
}

function updateDash(){
  els.dashTitle.textContent = `${state.rhythm} | Tone: ${state.tone || "—"}`;
  els.bpmLabel.textContent = `${state.bpm} BPM`;
}

function updateTrigger(){
  const cur = state.chordSteps[state.activeStep] || state.tone || "—";
  const nxt = state.chordSteps[state.activeStep + 1] || "—";
  els.nowChord.textContent = cur;
  els.nextChord.innerHTML = `Sắp tới: <strong>${nxt}</strong>`;
}

function clearCueStates(){
  for (const el of state.cueEls){
    if (!el) continue;
    el.removeAttribute("data-state");
  }
}

function setCueState(stepIndex, value){
  const el = state.cueEls[stepIndex];
  if (!el) return;
  el.setAttribute("data-state", value);
}

function scrollToCue(stepIndex){
  const el = state.cueEls[stepIndex];
  if (!el) return;
  el.scrollIntoView({ block:"center", behavior:"smooth" });
}

function renderPrompter(segments){
  els.prompter.innerHTML = "";
  state.cueEls = [];

  let stepCounter = 0;
  for (const seg of segments){
    const chord = seg.chord;
    const text = seg.text || "";

    // For each segment, we may create a cue for the first "word" after chord
    // and render the rest as normal text, preserving newlines.
    if (!chord){
      appendTextPreserveNewlines(els.prompter, text);
      continue;
    }

    // chord segment => stepCounter belongs to this chord
    const stepIndex = stepCounter++;

    // Find first non-space token to highlight
    const mm = text.match(/^(\s*)(\S+)?([\s\S]*)$/);
    const leading = (mm && mm[1]) ? mm[1] : "";
    const firstWord = (mm && mm[2]) ? mm[2] : "";
    const rest = (mm && mm[3]) ? mm[3] : "";

    // leading spaces/newlines
    appendTextPreserveNewlines(els.prompter, leading);

    if (firstWord){
      const cue = document.createElement("span");
      cue.className = "cue";
      cue.dataset.step = String(stepIndex);

      const tag = document.createElement("span");
      tag.className = "chordtag";
      tag.textContent = chord;

      cue.appendChild(tag);
      cue.appendChild(document.createTextNode(firstWord));

      els.prompter.appendChild(cue);
      state.cueEls[stepIndex] = cue;

      appendTextPreserveNewlines(els.prompter, rest);
    } else {
      // No word after chord: just render nothing, but keep step index for progression.
      // Provide a tiny invisible anchor to allow scrolling.
      const anchor = document.createElement("span");
      anchor.className = "cue";
      anchor.dataset.step = String(stepIndex);
      anchor.style.opacity = "0";
      anchor.textContent = "·";
      els.prompter.appendChild(anchor);
      state.cueEls[stepIndex] = anchor;
    }
  }

  // Add small spacing to avoid last line being stuck to bottom
  const gap = document.createElement("span");
  gap.className = "linegap";
  els.prompter.appendChild(gap);
}

function appendTextPreserveNewlines(container, text){
  if (!text) return;
  const parts = text.split("\n");
  for (let i=0;i<parts.length;i++){
    if (parts[i].length) container.appendChild(document.createTextNode(parts[i]));
    if (i < parts.length - 1) container.appendChild(document.createElement("br"));
  }
}

function applyActiveStep(newStep){
  newStep = Math.max(0, Math.min(state.chordSteps.length - 1, newStep));
  state.activeStep = newStep;

  clearCueStates();
  setCueState(state.activeStep, "active");
  setCueState(state.activeStep + 1, "upcoming");

  updateTrigger();
  scrollToCue(state.activeStep);
}

/* =========================
   Quantization logic
========================= */
function secondsIntoBar(){
  const barSec = Tone.Time("1m").toSeconds();
  const sec = Tone.Transport.seconds || 0;
  if (barSec <= 0) return 0;
  return sec % barSec;
}

function isNearBarStart(){
  const t = secondsIntoBar();
  // tolerance ~ 120ms near the downbeat
  return t < 0.12;
}

function requestStepChange(targetStep){
  if (!state.isPlaying) return;
  if (state.chordSteps.length === 0) return;

  targetStep = Math.max(0, Math.min(state.chordSteps.length - 1, targetStep));
  if (targetStep === state.activeStep) return;

  // If user hits near downbeat => apply immediately. Otherwise queue to next bar.
  if (isNearBarStart()){
    state.pendingStep = null;
    setPendingUI(false);
    applyActiveStep(targetStep);
  } else {
    state.pendingStep = targetStep;
    setPendingUI(true);
  }
}

function onBarBoundary(){
  if (state.pendingStep != null){
    const t = state.pendingStep;
    state.pendingStep = null;
    setPendingUI(false);
    applyActiveStep(t);
  }
}

/* =========================
   Playback control
========================= */
async function startPlayback(){
  const raw = els.songInput.value;
  const cleaned = cleanInput(raw);
  els.songInput.value = cleaned;
  localStorage.setItem("gnp_song_text", cleaned);
  localStorage.setItem("gnp_rhythm", els.rhythmSelect.value);

  const { meta, segments, chordSteps } = parseSong(cleaned);
  state.segments = segments;
  state.chordSteps = chordSteps;

  state.rhythm = els.rhythmSelect.value || meta.rhythm || "Bolero";
  state.tone = meta.tone || "Dm";
  state.bpm = (state.rhythm === "Bolero") ? 68 : 80;

  // If no chord steps, fallback to tone meta as a single step
  if (state.chordSteps.length === 0 && state.tone){
    state.chordSteps = [state.tone];
  }

  renderPrompter(state.segments);
  updateDash();
  updateTrigger();
  clearCueStates();
  setCueState(0, "active");
  setCueState(1, "upcoming");

  showStage();

  // Wake Lock (best effort)
  try{
    if ("wakeLock" in navigator){
      await navigator.wakeLock.request("screen");
    }
  }catch(e){}

  // Start audio
  await AudioEngine.start();
  AudioEngine.setBpm(state.bpm);

  // Pattern
  AudioEngine.playBolero(() => state.chordSteps[state.activeStep] || state.tone || "Dm");

  // Quantization watcher
  AudioEngine.scheduleBarWatcher(() => onBarBoundary());

  // Start transport
  Tone.Transport.start("+0.05");

  state.isPlaying = true;
  state.activeStep = 0;
  state.pendingStep = null;
  setPendingUI(false);

  applyActiveStep(0);
}

function stopPlayback(){
  if (!state.isPlaying){
    showSetup();
    return;
  }
  const cur = state.chordSteps[state.activeStep] || state.tone || "Dm";
  try{ AudioEngine.outro(cur); }catch(e){}

  // stop shortly after outro
  setTimeout(() => {
    AudioEngine.stopAll();
    state.isPlaying = false;
    state.pendingStep = null;
    setPendingUI(false);
    showSetup();
  }, 450);
}

/* =========================
   Gestures: tap / swipe-left / long-press
========================= */
function attachGestureHandlers(){
  const zone = els.triggerZone;

  zone.addEventListener("pointerdown", (ev) => {
    zone.setPointerCapture(ev.pointerId);
    state.pointerDownAt = { x: ev.clientX, y: ev.clientY, t: performance.now() };

    // long press => stop
    clearTimeout(state.pressTimer);
    state.pressTimer = setTimeout(() => {
      stopPlayback();
    }, 750);
  });

  zone.addEventListener("pointerup", (ev) => {
    clearTimeout(state.pressTimer);

    const down = state.pointerDownAt;
    state.pointerDownAt = null;
    if (!down) return;

    const dx = ev.clientX - down.x;
    const dy = ev.clientY - down.y;
    const dt = performance.now() - down.t;

    const isSwipeLeft = (dx < -60) && (Math.abs(dy) < 60) && (dt < 550);
    const isTap = (Math.abs(dx) < 20) && (Math.abs(dy) < 20) && (dt < 400);

    if (isSwipeLeft){
      // Undo: if pending exists, cancel it first; else step back
      if (state.pendingStep != null){
        state.pendingStep = null;
        setPendingUI(false);
      } else {
        requestStepChange(state.activeStep - 1);
      }
      return;
    }

    if (isTap){
      // Next
      requestStepChange(state.activeStep + 1);
    }
  });

  zone.addEventListener("pointercancel", () => {
    clearTimeout(state.pressTimer);
    state.pointerDownAt = null;
  });
}

/* =========================
   Events
========================= */
els.cleanBtn.addEventListener("click", () => {
  els.songInput.value = cleanInput(els.songInput.value);
});

els.startBtn.addEventListener("click", async () => {
  try{
    await startPlayback();
  }catch(e){
    alert("Không khởi chạy được audio. Hãy thử lại trên Chrome/Safari và đảm bảo bạn vừa bấm nút (user gesture).");
    console.error(e);
  }
});

els.bpmDown.addEventListener("click", () => {
  state.bpm = Math.max(40, state.bpm - 2);
  AudioEngine.setBpm(state.bpm);
  updateDash();
});
els.bpmUp.addEventListener("click", () => {
  state.bpm = Math.min(140, state.bpm + 2);
  AudioEngine.setBpm(state.bpm);
  updateDash();
});

// Persist + preload
(function init(){
  const saved = localStorage.getItem("gnp_song_text");
  const savedRhythm = localStorage.getItem("gnp_rhythm");

  const defaultText = `Tone: Dm
Điệu: Bolero

Intro: [Dm] [F] [C] [Dm] - [Bb] [C] [F] [Gm] - [Bb] [Am] [Dm] [Am7]

1. Say giấc mộng ban [Dm] đầu yêu [Bb] người thủa mới đôi [F] mươi em [C] đang độ trăng [Dm] tròn
Từng ngày qua [Bb] phố áo [C] em trắng cả đường [F] về
Lá [Gm] thư ướp mộng học [Bb] trò mối [Am]tình xanh như khúc [F] hát. [Dm7] [Am7]

2. Ai đã hẹn với [Dm] thề để [Bb] rồi lỡ mối duyên [F] thơ ra [C] đi chẳng giã [Dm] từ
Ngày em thay [Bb] áo áo [C] hoa pháo đỏ rượu [F] nồng
Có [Gm] ai nát cả cõi [Bb] lòng đứng [Am]nhìn em bước bên [Dm] chồng.

ĐK: Hai mươi [C] năm [Am] cuộc mộng dở [Dm] dang khắc sâu bóng [F] nàng
Lắng trong cung [Dm] đàn [C] em giờ ở [Dm]đâu hẳn vui duyên [F] mới
Hai mươi [C] năm [Am] cuộc rượu còn [Dm]đây uống qua tháng [F] ngày
Cố quên đi [Bb] người say [Am] hoài sầu không [Dm] vơi
Tình duyên ta [F] tiếc [Am] uống thêm ly [Dm]này.

3. [Am7] Ôm giấc mộng lỡ [Dm] làng những [Bb] chiều lắng tiếng mưa [F] rơi đêm [C] say chờ trăng [Dm] tàn
Từng thu thay [Bb] lá, lá [C] rơi đắp mộ cuộc [F] tình
Lá [Gm] bay chất nặng tuổi [Bb] đời nhớ [Am]người ta rót ly [Dm] này.
`;

  els.songInput.value = cleanInput(saved || defaultText);
  if (savedRhythm) els.rhythmSelect.value = savedRhythm;

  attachGestureHandlers();
  showSetup();
})();
</script>
</body>
</html>
