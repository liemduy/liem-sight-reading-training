<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tay Guitar Ảo (Nhậu Mode) — Click hợp âm là đệm (2 kiểu tay phải)</title>

  <!-- WebAudioFont core -->
  <script src="https://surikov.github.io/webaudiofont/npm/dist/WebAudioFontPlayer.js"></script>

  <style>
    :root { color-scheme: dark; --bg:#0b0f19; --card:#121a2b; --muted:#9fb0d0; --text:#e9eefc; --btn:#2a3b63; --btn2:#1e2a46; --accent:#7aa7ff; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 18px; }
    h1 { margin: 0 0 8px; font-size: 20px; font-weight: 800; letter-spacing: .2px; }
    p { margin: 6px 0 0; color: var(--muted); line-height: 1.45; }
    .grid { display:grid; grid-template-columns: 450px 1fr; gap: 14px; align-items:start; }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }

    .card { background: var(--card); border: 1px solid rgba(255,255,255,.08); border-radius: 14px; padding: 14px; }
    .row { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .spacer { height: 10px; }
    .pill { display:inline-flex; gap:8px; align-items:center; padding: 6px 10px; border-radius: 999px; border: 1px solid rgba(255,255,255,.12); color: var(--muted); font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .btn {
      appearance:none; border: 1px solid rgba(255,255,255,.12);
      background: var(--btn); color: var(--text);
      padding: 10px 12px; border-radius: 12px; cursor: pointer;
      font-weight: 700; letter-spacing: .2px;
    }
    .btn:hover { background: #324879; }
    .btn.secondary { background: var(--btn2); }
    .btn.danger { background: #4a1f2a; }
    .btn:disabled { opacity: .55; cursor:not-allowed; }
    select, textarea {
      background: #0f1627; color: var(--text);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 12px;
      padding: 10px 12px;
      outline: none;
    }
    textarea { width: 100%; height: 520px; resize: vertical; line-height: 1.35; }
    label { display:block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
    input[type="range"] { width: 240px; }
    hr { border: none; border-top: 1px solid rgba(255,255,255,.10); margin: 12px 0; }

    .song { font-size: 16px; line-height: 1.55; }
    .line { padding: 6px 0; border-bottom: 1px dashed rgba(255,255,255,.06); }
    .line:last-child { border-bottom: none; }
    .sectionTitle { margin-top: 12px; font-weight: 800; color: #cfe0ff; }

    .chord {
      display:inline-flex; align-items:center; justify-content:center;
      margin: 0 4px;
      padding: 3px 10px;
      border-radius: 999px;
      border: 1px solid rgba(122,167,255,.55);
      background: rgba(122,167,255,.12);
      color: #dbe8ff;
      font-weight: 800;
      cursor: pointer;
      user-select: none;
      transform: translateY(-1px);
    }
    .chord:hover { background: rgba(122,167,255,.18); }
    .chord.active { background: rgba(122,167,255,.28); border-color: rgba(122,167,255,.9); box-shadow: 0 0 0 2px rgba(122,167,255,.15) inset; }

    .hint { font-size: 12px; color: var(--muted); }
    .kbd { border: 1px solid rgba(255,255,255,.14); border-bottom-width: 2px; border-radius: 8px; padding: 2px 6px; background: rgba(255,255,255,.06); font-size: 12px; }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>Tay Guitar Ảo (Nhậu Mode) — Click hợp âm là đệm (2 kiểu tay phải)</h1>
    <p>
      Bạn chọn “Tay phải”: <b>Móc dây</b> hoặc <b>Bass + chát</b>. Người hát tới đâu bấm hợp âm tới đó.
      <b>Hold ON</b> = đệm nền và đổi hợp âm ở đầu ô nhịp kế tiếp.
    </p>

    <div class="grid">
      <!-- LEFT -->
      <div class="card">
        <div class="row">
          <button id="btnEnable" class="btn">Bật âm thanh</button>
          <span class="pill">Audio: <span id="audioState" class="mono">OFF</span></span>
          <span class="pill">Preset: <span id="presetState" class="mono">chưa nạp</span></span>
        </div>

        <div class="spacer"></div>

        <div class="row">
          <div>
            <label>Guitar preset</label>
            <select id="presetSel">
              <option value="nylon_lk">Acoustic Nylon — LK (bolero mềm)</option>
              <option value="steel_lk">Acoustic Steel — LK (đậm, rõ)</option>
              <option value="steel_std">Acoustic Steel — Standard</option>
              <option value="elec_clean">Electric Clean — Aspirin</option>
              <option value="elec_jazz">Electric Jazz — Aspirin</option>
              <option value="elec_muted">Electric Muted — Aspirin (cộc)</option>
            </select>
          </div>
          <div style="margin-top:18px">
            <button id="btnLoadPreset" class="btn secondary" disabled>Nạp preset</button>
          </div>
        </div>

        <div class="spacer"></div>

        <div class="row">
          <div>
            <label>BPM</label>
            <input id="bpm" type="range" min="55" max="200" value="84" />
            <span class="pill"><span id="bpmVal" class="mono">84</span> BPM</span>
          </div>
          <div>
            <label>Tap tempo</label>
            <button id="btnTap" class="btn secondary" disabled>Tap</button>
          </div>
        </div>

        <div class="row">
          <div>
            <label>Tay phải (chọn 1)</label>
            <select id="rightHand">
              <option value="pick" selected>Bolero móc dây (arpeggio 1&2&3&4&)</option>
              <option value="basschat">Bolero bass + chát (1-2-3-4)</option>
            </select>
          </div>
          <span class="pill">Hold: <span id="holdState" class="mono">OFF</span></span>
        </div>

        <div class="row">
          <div>
            <label>Độ “lơi” (chậm/quạt mềm hơn)</label>
            <input id="loi" type="range" min="0" max="100" value="55" />
            <span class="pill">Lơi: <span id="loiVal" class="mono">55</span></span>
          </div>
        </div>

        <div class="row">
          <div>
            <label>Humanize (độ “người”)</label>
            <input id="human" type="range" min="0" max="100" value="45" />
            <span class="pill">Human: <span id="humanVal" class="mono">45</span></span>
          </div>
        </div>

        <div class="row">
          <button id="btnHold" class="btn secondary" disabled>Bật Hold (đệm nền)</button>
          <button id="btnStop" class="btn danger" disabled>Stop (tắt tiếng)</button>

          <label class="pill" style="cursor:pointer">
            <input id="metro" type="checkbox" style="transform:scale(1.05)" />
            Metronome
          </label>
        </div>

        <hr />

        <div class="row">
          <div style="flex:1; min-width: 260px">
            <label>Input (dán bài vào đây)</label>
            <textarea id="input"></textarea>
          </div>
        </div>

        <div class="row">
          <button id="btnRender" class="btn secondary" disabled>Render + Bấm hợp âm để đệm</button>
          <button id="btnExample" class="btn secondary">Nạp ví dụ (tone Dm, bolero)</button>
        </div>

        <p class="hint">
          Phím tắt: <span class="kbd">Space</span> = Stop. Gợi ý: bolero mềm nhất thường dùng <b>Nylon</b>. Nếu thấy “vội”, tăng <b>Lơi</b> lên 70–80.
        </p>
      </div>

      <!-- RIGHT -->
      <div class="card">
        <div class="row">
          <span class="pill">Tone: <span id="metaTone" class="mono">—</span></span>
          <span class="pill">Điệu: <span id="metaStyle" class="mono">—</span></span>
          <span class="pill">Current: <span id="nowChord" class="mono">—</span></span>
          <span class="pill">Pending: <span id="pendingChord" class="mono">—</span></span>
        </div>

        <div class="spacer"></div>
        <div id="song" class="song">
          <p class="muted">Bấm “Render…” để hiện lời + hợp âm clickable.</p>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ------------------------------
  // Instrument catalog (dynamic load)
  // ------------------------------
  const BASE = "https://surikov.github.io/webaudiofontdata/sound/";
  const INSTRUMENTS = {
    nylon_lk:   { label:"Acoustic Nylon — LK",      file:"0240_LK_Godin_Nylon_SF2_file.js",   varName:"_tone_0240_LK_Godin_Nylon_SF2_file" },
    steel_lk:   { label:"Acoustic Steel — LK",      file:"0250_LK_AcousticSteel_SF2_file.js", varName:"_tone_0250_LK_AcousticSteel_SF2_file" },
    steel_std:  { label:"Acoustic Steel — Standard",file:"0250_Acoustic_Guitar_sf2_file.js",  varName:"_tone_0250_Acoustic_Guitar_sf2_file" },
    elec_clean: { label:"Electric Clean — Aspirin", file:"0270_Aspirin_sf2_file.js",          varName:"_tone_0270_Aspirin_sf2_file" },
    elec_jazz:  { label:"Electric Jazz — Aspirin",  file:"0260_Aspirin_sf2_file.js",          varName:"_tone_0260_Aspirin_sf2_file" },
    elec_muted: { label:"Electric Muted — Aspirin", file:"0280_Aspirin_sf2_file.js",          varName:"_tone_0280_Aspirin_sf2_file" },
  };

  // ------------------------------
  // DOM
  // ------------------------------
  const $ = (s) => document.querySelector(s);
  const el = {
    btnEnable: $("#btnEnable"),
    btnLoadPreset: $("#btnLoadPreset"),
    presetSel: $("#presetSel"),
    presetState: $("#presetState"),
    audioState: $("#audioState"),

    bpm: $("#bpm"),
    bpmVal: $("#bpmVal"),
    btnTap: $("#btnTap"),

    rightHand: $("#rightHand"),

    loi: $("#loi"),
    loiVal: $("#loiVal"),
    human: $("#human"),
    humanVal: $("#humanVal"),

    btnHold: $("#btnHold"),
    holdState: $("#holdState"),
    btnStop: $("#btnStop"),
    metro: $("#metro"),

    input: $("#input"),
    btnRender: $("#btnRender"),
    btnExample: $("#btnExample"),

    metaTone: $("#metaTone"),
    metaStyle: $("#metaStyle"),
    nowChord: $("#nowChord"),
    pendingChord: $("#pendingChord"),
    song: $("#song"),
  };

  // ------------------------------
  // Audio engine
  // ------------------------------
  const AudioContextFunc = window.AudioContext || window.webkitAudioContext;
  let ctx = null;
  let player = null;
  let preset = null;

  let masterGain, compressor, hp, lp, convolver, wetGain, dryGain, outGain;

  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  function randSigned(){ return (Math.random()*2 - 1); }
  function human01() { return Number(el.human.value)/100; }
  function loi01() { return Number(el.loi.value)/100; }
  function secPerBeat() { return 60 / Number(el.bpm.value); }
  function barDur() { return secPerBeat() * 4; } // 4/4

  function makeImpulseResponse(context, seconds = 1.2, decay = 3.6) {
    const rate = context.sampleRate;
    const length = Math.max(1, Math.floor(rate * seconds));
    const ir = context.createBuffer(2, length, rate);
    for (let ch = 0; ch < 2; ch++) {
      const data = ir.getChannelData(ch);
      for (let i = 0; i < length; i++) {
        const t = i / length;
        const env = Math.pow(1 - t, decay);
        data[i] = (Math.random() * 2 - 1) * env;
      }
    }
    return ir;
  }

  async function ensureAudio() {
    if (!ctx) {
      ctx = new AudioContextFunc();
      player = new WebAudioFontPlayer();

      masterGain = ctx.createGain();
      masterGain.gain.value = 0.95;

      compressor = ctx.createDynamicsCompressor();
      compressor.threshold.value = -28;
      compressor.knee.value = 18;
      compressor.ratio.value = 2.2;
      compressor.attack.value = 0.010;
      compressor.release.value = 0.20;

      hp = ctx.createBiquadFilter();
      hp.type = "highpass";
      hp.frequency.value = 80;
      hp.Q.value = 0.7;

      lp = ctx.createBiquadFilter();
      lp.type = "lowpass";
      lp.frequency.value = 9000;
      lp.Q.value = 0.7;

      convolver = ctx.createConvolver();
      convolver.buffer = makeImpulseResponse(ctx);

      wetGain = ctx.createGain();
      wetGain.gain.value = 0.16;

      dryGain = ctx.createGain();
      dryGain.gain.value = 1.0;

      outGain = ctx.createGain();
      outGain.gain.value = 0.95;

      masterGain.connect(compressor);
      compressor.connect(hp);
      hp.connect(lp);

      lp.connect(dryGain);
      lp.connect(convolver);
      convolver.connect(wetGain);

      dryGain.connect(outGain);
      wetGain.connect(outGain);
      outGain.connect(ctx.destination);
    }
    if (ctx.state !== "running") await ctx.resume();

    el.audioState.textContent = "ON";
    el.btnLoadPreset.disabled = false;
    el.btnRender.disabled = false;
    el.btnTap.disabled = false;
    el.btnHold.disabled = false;
    el.btnStop.disabled = false;
  }

  function loadPresetByKey(key) {
    if (!ctx || !player) return;
    const instr = INSTRUMENTS[key] || INSTRUMENTS.nylon_lk;
    el.presetState.textContent = "loading...";
    const url = BASE + instr.file;
    player.loader.startLoad(ctx, url, instr.varName);
    player.loader.waitLoad(() => {
      preset = window[instr.varName];
      player.loader.decodeAfterLoading(ctx, instr.varName);
      el.presetState.textContent = instr.label;
    });
  }

  // ------------------------------
  // Metronome
  // ------------------------------
  let metroTimer = null;
  function metroClick(when, accent=false) {
    if (!ctx) return;
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = "square";
    o.frequency.setValueAtTime(accent ? 1650 : 1300, when);
    g.gain.setValueAtTime(0.0001, when);
    g.gain.linearRampToValueAtTime(accent ? 0.20 : 0.14, when + 0.002);
    g.gain.exponentialRampToValueAtTime(0.0001, when + 0.04);
    o.connect(g);
    g.connect(ctx.destination);
    o.start(when);
    o.stop(when + 0.06);
  }
  function startMetronome() {
    stopMetronome();
    let next = ctx.currentTime + 0.02;
    let beat = 0;
    const lookahead = 0.12;
    const tick = () => {
      const spb = secPerBeat();
      while (next < ctx.currentTime + lookahead) {
        metroClick(next, (beat % 4 === 0));
        next += spb;
        beat++;
      }
      metroTimer = setTimeout(tick, 25);
    };
    tick();
  }
  function stopMetronome() {
    if (metroTimer) clearTimeout(metroTimer);
    metroTimer = null;
  }

  // ------------------------------
  // Guitar shapes (tay trái): 6 dây từ (6 -> 1) theo standard tuning
  // Shape array length 6: number fret or 'x'
  // MIDI open strings: E2=40, A2=45, D3=50, G3=55, B3=59, E4=64
  // ------------------------------
  const OPEN_MIDI = [40, 45, 50, 55, 59, 64]; // strings 6..1

  const SHAPES = {
    // Core for your song
    "Dm":  ['x','x',0,2,3,1],       // xx0231
    "Dm7": ['x','x',0,2,1,1],       // xx0211
    "Am":  ['x',0,2,2,1,0],         // x02210
    "Am7": ['x',0,2,0,1,0],         // x02010
    "Bb":  ['x',1,3,3,3,1],         // x13331
    "C":   ['x',3,2,0,1,0],         // x32010
    "F":   [1,3,3,2,1,1],           // 133211
    "Gm":  [3,5,5,3,3,3],           // 355333
    "G":   [3,2,0,0,0,3],           // 320003
    "G7":  [3,2,0,0,0,1],           // 320001
    "A7":  ['x',0,2,0,2,0],         // x02020
    // Extras (nice to have)
    "D7":  ['x','x',0,2,1,2],       // xx0212
    "Em":  [0,2,2,0,0,0],           // 022000
    "E7":  [0,2,0,1,0,0],           // 020100
  };

  // Lightweight fallback: turn unknown chord into a "safe" pseudo-shape on top 4 strings
  // (not perfect, but avoids crashing)
  const NOTE = { C:0, D:2, E:4, F:5, G:7, A:9, B:11 };
  function parseChordSymbol(symRaw) {
    const sym = symRaw.trim().replace("Δ","maj");
    let main = sym;
    const slashIdx = sym.indexOf("/");
    if (slashIdx >= 0) main = sym.slice(0, slashIdx).trim();

    const m = main.match(/^([A-G])([#b]?)(.*)$/);
    if (!m) return { ok:false, sym };

    const root = m[1], acc = m[2] || "";
    let qual = (m[3] || "").trim();

    let triad = "maj";
    if (/^m(?!aj)/i.test(qual) || /^min/i.test(qual)) triad = "min";

    const rootSemitone = (NOTE[root] + (acc === "#" ? 1 : acc === "b" ? -1 : 0) + 12) % 12;
    return { ok:true, sym, rootSemitone, triad };
  }

  function shapeToPitches(shape) {
    // returns array of {string: 6..1, midi, fret}
    const out = [];
    for (let i = 0; i < 6; i++) {
      const fret = shape[i];
      if (fret === 'x' || fret === 'X') continue;
      const midi = OPEN_MIDI[i] + Number(fret);
      out.push({ string: 6 - i, midi, fret: Number(fret) });
    }
    return out;
  }

  function getShape(chordSym) {
    const s = chordSym.trim();
    if (SHAPES[s]) return SHAPES[s];

    // fallback pseudo shape: place triad on strings 4-3-2-1 around fret 5-ish
    const p = parseChordSymbol(s);
    if (!p.ok) return ['x','x',0,2,3,1]; // fallback Dm

    // root on string 4 around D3 (50) + semitone shift
    // use simple power voicing: root (string4), 3rd (string3), 5th (string2), octave (string1)
    const base = 50 + p.rootSemitone; // around D3..?
    const i3 = (p.triad === "min") ? 3 : 4;
    const i5 = 7;
    const pitches = [base, base+i3, base+i5, base+12];

    // convert to frets on strings 4..1
    const strings = [4,3,2,1];
    const shape = ['x','x','x','x','x','x'];
    for (let k = 0; k < 4; k++) {
      const str = strings[k];
      const open = OPEN_MIDI[6 - str];
      let fret = pitches[k] - open;
      fret = clamp(Math.round(fret), 0, 12);
      shape[6 - str] = fret;
    }
    // prefer bass on string 5 open if possible
    shape[1] = 0; // A string open as neutral bass (won't always be right but ok)
    return shape;
  }

  function chooseBassString(shape) {
    // Prefer lowest available: string6 then 5 then 4
    if (shape[0] !== 'x' && shape[0] !== 'X') return 6;
    if (shape[1] !== 'x' && shape[1] !== 'X') return 5;
    if (shape[2] !== 'x' && shape[2] !== 'X') return 4;
    return 5;
  }

  function getMidiForString(shape, stringNum) {
    // stringNum: 6..1
    const idx = 6 - stringNum; // 0..5
    const fret = shape[idx];
    if (fret === 'x' || fret === 'X') return null;
    return OPEN_MIDI[idx] + Number(fret);
  }

  // ------------------------------
  // Right-hand engine (tay phải)
  // ------------------------------

  // Small “chát” noise layer (optional, low volume) to mimic palm-mute percussive feel
  function noiseChop(when, vol=0.08) {
    if (!ctx) return;
    const dur = 0.05;
    const buffer = ctx.createBuffer(1, Math.floor(ctx.sampleRate * dur), ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);

    const src = ctx.createBufferSource();
    src.buffer = buffer;

    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.value = 1800;
    bp.Q.value = 0.8;

    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, when);
    g.gain.linearRampToValueAtTime(vol, when + 0.002);
    g.gain.exponentialRampToValueAtTime(0.0001, when + dur);

    src.connect(bp);
    bp.connect(g);
    g.connect(outGain); // into output (post FX)

    src.start(when);
    src.stop(when + dur + 0.01);
  }

  function pickString(chordSym, when, stringNum, dur, vol) {
    if (!ctx || !player || !preset) return;
    const shape = getShape(chordSym);
    const midi = getMidiForString(shape, stringNum);
    if (midi == null) return;

    const h = human01();
    const t = when + randSigned() * clamp(secPerBeat() * (0.001 + 0.008*h), 0.001, 0.010);
    const v = clamp(vol + randSigned() * (0.06*h), 0.12, 0.98);
    player.queueWaveTable(ctx, masterGain, preset, t, midi, dur, v);
  }

  function brushTreble(chordSym, when, dir, dur, vol, muted=true) {
    // brush across strings 4-3-2-1 (or reverse) with spread
    const spb = secPerBeat();
    const loi = loi01();
    const h = human01();
    const spread = clamp(spb * (0.012 + 0.028*loi), 0.010, 0.050); // 10..50ms
    const stringsDown = [4,3,2,1];
    const strings = (dir === "up") ? [...stringsDown].reverse() : stringsDown;
    const ndur = muted ? clamp(dur * 0.35, 0.10, 0.40) : dur;

    strings.forEach((s, i) => {
      const v = clamp(vol * (1 - 0.08*i) + randSigned()*(0.04*h), 0.10, 0.95);
      pickString(chordSym, when + i*spread, s, ndur, v);
    });

    // add subtle percussive "chát"
    if (muted) noiseChop(when + spread*0.6, 0.07 * (0.7 + 0.6*h));
  }

  // Option 1: Bolero móc dây (1 & 2 & 3 & 4 &)
  function scheduleBoleroPickOneBar(chordSym, barStart) {
    const durBar = barDur();
    const durNote = clamp(secPerBeat() * 0.55, 0.18, 0.55); // pluck length
    const shape = getShape(chordSym);
    const bass1 = chooseBassString(shape);
    const bass2 = (getMidiForString(shape, 4) != null) ? 4 : bass1;

    // 8 events (1&2&3&4&)
    const ev = [
      {t:0.00,  fn:() => pickString(chordSym, barStart + 0.00*durBar, bass1, durNote, 0.92)},
      {t:0.125, fn:() => pickString(chordSym, barStart + 0.125*durBar, 3,     durNote, 0.50)},
      {t:0.25,  fn:() => pickString(chordSym, barStart + 0.25*durBar,  2,     durNote, 0.48)},
      {t:0.375, fn:() => pickString(chordSym, barStart + 0.375*durBar, 1,     durNote, 0.46)},
      {t:0.50,  fn:() => pickString(chordSym, barStart + 0.50*durBar,  bass2, durNote, 0.84)},
      {t:0.625, fn:() => pickString(chordSym, barStart + 0.625*durBar, 3,     durNote, 0.50)},
      {t:0.75,  fn:() => pickString(chordSym, barStart + 0.75*durBar,  2,     durNote, 0.48)},
      {t:0.875, fn:() => pickString(chordSym, barStart + 0.875*durBar, 1,     durNote, 0.46)},
    ];
    ev.forEach(x => x.fn());
  }

  // Option 2: Bolero bass + chát (1-2-3-4)
  function scheduleBoleroBassChatOneBar(chordSym, barStart) {
    const durBar = barDur();
    const durBass = clamp(secPerBeat() * 0.45, 0.16, 0.50);
    const shape = getShape(chordSym);
    const bass1 = chooseBassString(shape);
    const bass2 = (getMidiForString(shape, 4) != null) ? 4 : bass1;

    // 1: bass, 2: chat, 3: bass, 4: chat
    pickString(chordSym, barStart + 0.00*durBar, bass1, durBass, 0.95);
    brushTreble(chordSym, barStart + 0.25*durBar, "down", durBar*0.9, 0.56, true);

    pickString(chordSym, barStart + 0.50*durBar, bass2, durBass, 0.86);
    brushTreble(chordSym, barStart + 0.75*durBar, "down", durBar*0.9, 0.52, true);
  }

  function scheduleOneBar(chordSym, barStart) {
    if (!ctx || !preset) return;
    if (el.rightHand.value === "pick") scheduleBoleroPickOneBar(chordSym, barStart);
    else scheduleBoleroBassChatOneBar(chordSym, barStart);
  }

  // ------------------------------
  // One-shot + anti “dính bùn”
  // ------------------------------
  let lastOneShotAt = 0;
  function playOneShotBar(chordSym) {
    if (!ctx || !preset) return;

    const now = ctx.currentTime;
    const minGap = clamp(barDur() * 0.35, 0.25, 0.80);
    if (now - lastOneShotAt < minGap) player.cancelQueue(ctx);
    lastOneShotAt = now;

    scheduleOneBar(chordSym, now + 0.03);
  }

  // ------------------------------
  // Hold mode
  // ------------------------------
  let holdOn = false;
  let holding = false;
  let currentChord = null;
  let pendingChord = null;

  let schedTimer = null;
  let nextBarTime = 0;

  function setNowChord(sym) { currentChord = sym; el.nowChord.textContent = sym || "—"; }
  function setPendingChord(sym) { pendingChord = sym; el.pendingChord.textContent = sym || "—"; }

  function reanchorHold() { nextBarTime = ctx.currentTime + 0.10; }

  function startHoldLoop(initialChord) {
    if (!ctx || !preset) return;
    holding = true;
    setNowChord(initialChord);
    setPendingChord(null);

    nextBarTime = ctx.currentTime + 0.10;

    const lookahead = 0.24;
    const tick = () => {
      if (!holding) return;

      while (nextBarTime < ctx.currentTime + lookahead) {
        if (pendingChord) { setNowChord(pendingChord); setPendingChord(null); }
        scheduleOneBar(currentChord, nextBarTime);
        nextBarTime += barDur();
      }
      schedTimer = setTimeout(tick, 25);
    };
    tick();
  }

  function stopAll() {
    holding = false;
    holdOn = false;
    el.holdState.textContent = "OFF";
    el.btnHold.textContent = "Bật Hold (đệm nền)";

    if (schedTimer) clearTimeout(schedTimer);
    schedTimer = null;

    if (player && ctx) player.cancelQueue(ctx);
    setNowChord(null);
    setPendingChord(null);

    if (el.metro.checked) {
      el.metro.checked = false;
      stopMetronome();
    }
  }

  // ------------------------------
  // Rendering chord sheet
  // ------------------------------
  function parseMetadata(text) {
    const tone = (text.match(/^\s*Tone:\s*(.+)\s*$/mi) || [])[1]?.trim() || "—";
    const style = (text.match(/^\s*Điệu:\s*(.+)\s*$/mi) || [])[1]?.trim() || "—";
    return { tone, style };
  }
  function isSectionTitle(line) {
    return /^\s*(Intro:|ĐK:|DK:|Điệp khúc:|Chorus:|Verse\s*\d+|Bridge:|\d+\.)/i.test(line.trim());
  }
  function renderSong(text) {
    const { tone, style } = parseMetadata(text);
    el.metaTone.textContent = tone;
    el.metaStyle.textContent = style;

    const lines = text.replace(/\r/g, "").split("\n");
    const container = document.createElement("div");

    for (const rawLine of lines) {
      const line = rawLine.trimEnd();

      if (!line.trim()) {
        const spacer = document.createElement("div");
        spacer.className = "line";
        spacer.style.borderBottom = "none";
        spacer.innerHTML = "&nbsp;";
        container.appendChild(spacer);
        continue;
      }
      if (/^\s*Tone\s*:/i.test(line) || /^\s*Điệu\s*:/i.test(line)) continue;

      const div = document.createElement("div");
      div.className = "line";

      if (isSectionTitle(line)) {
        const t = document.createElement("div");
        t.className = "sectionTitle";
        t.textContent = line;
        div.appendChild(t);
        container.appendChild(div);
        continue;
      }

      const parts = [];
      const re = /\[([^\]]+)\]/g;
      let lastIdx = 0, m;
      while ((m = re.exec(line)) !== null) {
        const before = line.slice(lastIdx, m.index);
        if (before) parts.push({ type:"text", value: before });
        parts.push({ type:"chord", value: m[1].trim() });
        lastIdx = m.index + m[0].length;
      }
      const tail = line.slice(lastIdx);
      if (tail) parts.push({ type:"text", value: tail });

      for (const p of parts) {
        if (p.type === "text") div.appendChild(document.createTextNode(p.value));
        else {
          const sp = document.createElement("span");
          sp.className = "chord";
          sp.textContent = p.value;

          sp.addEventListener("click", async () => {
            await ensureAudio();
            if (!preset) loadPresetByKey(el.presetSel.value);

            document.querySelectorAll(".chord.active").forEach(x => x.classList.remove("active"));
            sp.classList.add("active");

            if (holdOn) {
              if (!holding) startHoldLoop(p.value);
              else setPendingChord(p.value);
            } else {
              setNowChord(p.value);
              setPendingChord(null);
              playOneShotBar(p.value);
            }
          });

          div.appendChild(sp);
        }
      }
      container.appendChild(div);
    }

    el.song.innerHTML = "";
    el.song.appendChild(container);
  }

  // ------------------------------
  // UI wiring
  // ------------------------------
  el.bpm.addEventListener("input", () => {
    el.bpmVal.textContent = el.bpm.value;
    if (ctx && el.metro.checked) startMetronome();
    if (holding) reanchorHold();
  });

  el.loi.addEventListener("input", () => el.loiVal.textContent = el.loi.value);
  el.human.addEventListener("input", () => el.humanVal.textContent = el.human.value);

  // Tap tempo
  let tapTimes = [];
  el.btnTap.addEventListener("click", () => {
    const t = performance.now();
    tapTimes.push(t);
    if (tapTimes.length > 7) tapTimes.shift();
    if (tapTimes.length >= 3) {
      let sum = 0;
      for (let i = 1; i < tapTimes.length; i++) sum += (tapTimes[i] - tapTimes[i-1]);
      const avgMs = sum / (tapTimes.length - 1);
      const bpm = clamp(Math.round(60000 / avgMs), 55, 200);
      el.bpm.value = String(bpm);
      el.bpmVal.textContent = String(bpm);
      if (ctx && el.metro.checked) startMetronome();
      if (holding) reanchorHold();
    }
  });

  el.btnEnable.addEventListener("click", async () => {
    await ensureAudio();
    loadPresetByKey(el.presetSel.value);
  });
  el.btnLoadPreset.addEventListener("click", async () => {
    await ensureAudio();
    loadPresetByKey(el.presetSel.value);
  });
  el.presetSel.addEventListener("change", () => { if (ctx) loadPresetByKey(el.presetSel.value); });

  el.btnRender.addEventListener("click", async () => {
    await ensureAudio();
    renderSong(el.input.value);
  });

  el.btnExample.addEventListener("click", () => {
    el.input.value = EXAMPLE;
    if (ctx) renderSong(el.input.value);
  });

  el.btnHold.addEventListener("click", async () => {
    await ensureAudio();
    holdOn = !holdOn;
    el.holdState.textContent = holdOn ? "ON" : "OFF";
    el.btnHold.textContent = holdOn ? "Tắt Hold (đệm nền)" : "Bật Hold (đệm nền)";

    if (!holdOn && holding) {
      holding = false;
      if (schedTimer) clearTimeout(schedTimer);
      schedTimer = null;
      setPendingChord(null);
    }
  });

  el.btnStop.addEventListener("click", () => stopAll());

  el.metro.addEventListener("change", async () => {
    await ensureAudio();
    if (el.metro.checked) startMetronome();
    else stopMetronome();
  });

  window.addEventListener("keydown", (e) => {
    if (e.code === "Space") { e.preventDefault(); stopAll(); }
  });

  document.addEventListener("visibilitychange", () => { if (document.hidden) stopAll(); });

  // ------------------------------
  // Example input (your sample)
  // ------------------------------
  const EXAMPLE =
`Tone: Dm
Điệu: Bolero

Intro: [Dm] [F] [C] [Dm] - [Bb] [C] [F] [Gm] - [Bb] [Am] [Dm] [Am7]

1. Say giấc mộng ban [Dm] đầu yêu [Bb] người thủa mới đôi [F] mươi em [C] đang độ trăng [Dm] tròn
Từng ngày qua [Bb] phố áo [C] em trắng cả đường [F] về
Lá [Gm] thư ướp mộng học [Bb] trò mối [Am]tình xanh như khúc [F] hát. [Dm7] [Am7]

2. Ai đã hẹn với [Dm] thề để [Bb] rồi lỡ mối duyên [F] thơ ra [C] đi chẳng giã [Dm] từ
Ngày em thay [Bb] áo áo [C] hoa pháo đỏ rượu [F] nồng
Có [Gm] ai nát cả cõi [Bb] lòng đứng [Am]nhìn em bước bên [Dm] chồng.

ĐK: Hai mươi [C] năm [Am] cuộc mộng dở [Dm] dang khắc sâu bóng [F] nàng
Lắng trong cung [Dm] đàn [C] em giờ ở [Dm]đâu hẳn vui duyên [F] mới
Hai mươi [C] năm [Am] cuộc rượu còn [Dm]đây uống qua tháng [F] ngày
Cố quên đi [Bb] người say [Am] hoài sầu không [Dm] vơi
Tình duyên ta [F] tiếc [Am] uống thêm ly [Dm]này.

3. [Am7] Ôm giấc mộng lỡ [Dm] làng những [Bb] chiều lắng tiếng mưa [F] rơi đêm [C] say chờ trăng [Dm] tàn
Từng thu thay [Bb] lá, lá [C] rơi đắp mộ cuộc [F] tình
Lá [Gm] bay chất nặng tuổi [Bb] đời nhớ [Am]người ta rót ly [Dm] này.`;

  el.input.value = EXAMPLE;
  el.bpmVal.textContent = el.bpm.value;
  el.loiVal.textContent = el.loi.value;
  el.humanVal.textContent = el.human.value;

})();
</script>
</body>
</html>