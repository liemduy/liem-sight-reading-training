<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tay Guitar Ảo (Nhậu Mode) — Click hợp âm là đệm (Bolero thật hơn)</title>

  <!-- WebAudioFont core -->
  <script src="https://surikov.github.io/webaudiofont/npm/dist/WebAudioFontPlayer.js"></script>

  <style>
    :root { color-scheme: dark; --bg:#0b0f19; --card:#121a2b; --muted:#9fb0d0; --text:#e9eefc; --btn:#2a3b63; --btn2:#1e2a46; --accent:#7aa7ff; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 18px; }
    h1 { margin: 0 0 8px; font-size: 20px; font-weight: 800; letter-spacing: .2px; }
    p { margin: 6px 0 0; color: var(--muted); line-height: 1.45; }
    .grid { display:grid; grid-template-columns: 430px 1fr; gap: 14px; align-items:start; }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }

    .card { background: var(--card); border: 1px solid rgba(255,255,255,.08); border-radius: 14px; padding: 14px; }
    .row { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .spacer { height: 10px; }
    .pill { display:inline-flex; gap:8px; align-items:center; padding: 6px 10px; border-radius: 999px; border: 1px solid rgba(255,255,255,.12); color: var(--muted); font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .btn {
      appearance:none; border: 1px solid rgba(255,255,255,.12);
      background: var(--btn); color: var(--text);
      padding: 10px 12px; border-radius: 12px; cursor: pointer;
      font-weight: 700; letter-spacing: .2px;
    }
    .btn:hover { background: #324879; }
    .btn.secondary { background: var(--btn2); }
    .btn.danger { background: #4a1f2a; }
    .btn:disabled { opacity: .55; cursor:not-allowed; }
    select, input[type="number"], textarea {
      background: #0f1627; color: var(--text);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 12px;
      padding: 10px 12px;
      outline: none;
    }
    textarea { width: 100%; height: 520px; resize: vertical; line-height: 1.35; }
    label { display:block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
    input[type="range"] { width: 240px; }
    hr { border: none; border-top: 1px solid rgba(255,255,255,.10); margin: 12px 0; }

    .song { font-size: 16px; line-height: 1.55; }
    .line { padding: 6px 0; border-bottom: 1px dashed rgba(255,255,255,.06); }
    .line:last-child { border-bottom: none; }
    .sectionTitle { margin-top: 12px; font-weight: 800; color: #cfe0ff; }

    .chord {
      display:inline-flex; align-items:center; justify-content:center;
      margin: 0 4px;
      padding: 3px 10px;
      border-radius: 999px;
      border: 1px solid rgba(122,167,255,.55);
      background: rgba(122,167,255,.12);
      color: #dbe8ff;
      font-weight: 800;
      cursor: pointer;
      user-select: none;
      transform: translateY(-1px);
    }
    .chord:hover { background: rgba(122,167,255,.18); }
    .chord.active { background: rgba(122,167,255,.28); border-color: rgba(122,167,255,.9); box-shadow: 0 0 0 2px rgba(122,167,255,.15) inset; }

    .hint { font-size: 12px; color: var(--muted); }
    .kbd { border: 1px solid rgba(255,255,255,.14); border-bottom-width: 2px; border-radius: 8px; padding: 2px 6px; background: rgba(255,255,255,.06); font-size: 12px; }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>Tay Guitar Ảo (Nhậu Mode) — Click hợp âm là đệm (Bolero thật hơn)</h1>
    <p>
      Dán input dạng <span class="mono">[Chord]</span>. Người hát tới đâu bạn bấm tới đó.
      <b>Hold ON</b> = đệm nền bolero và đổi hợp âm “ăn” vào đầu ô nhịp kế tiếp.
    </p>

    <div class="grid">
      <!-- LEFT -->
      <div class="card">
        <div class="row">
          <button id="btnEnable" class="btn">Bật âm thanh</button>
          <span class="pill">Audio: <span id="audioState" class="mono">OFF</span></span>
          <span class="pill">Preset: <span id="presetState" class="mono">chưa nạp</span></span>
        </div>

        <div class="spacer"></div>

        <div class="row">
          <div>
            <label>Guitar preset</label>
            <select id="presetSel">
              <option value="nylon_lk">Acoustic Nylon — LK (bolero mềm)</option>
              <option value="steel_lk">Acoustic Steel — LK (đậm, rõ)</option>
              <option value="steel_std">Acoustic Steel — Standard</option>
              <option value="elec_clean">Electric Clean — Aspirin</option>
              <option value="elec_jazz">Electric Jazz — Aspirin</option>
              <option value="elec_muted">Electric Muted — Aspirin (cộc)</option>
            </select>
          </div>
          <div style="margin-top:18px">
            <button id="btnLoadPreset" class="btn secondary" disabled>Nạp preset</button>
          </div>
        </div>

        <div class="spacer"></div>

        <div class="row">
          <div>
            <label>BPM</label>
            <input id="bpm" type="range" min="55" max="200" value="84" />
            <span class="pill"><span id="bpmVal" class="mono">84</span> BPM</span>
          </div>

          <div>
            <label>Tap tempo</label>
            <button id="btnTap" class="btn secondary" disabled>Tap</button>
            <span class="pill">Hold: <span id="holdState" class="mono">OFF</span></span>
          </div>
        </div>

        <div class="row">
          <div>
            <label>Strum “lơi” (chậm hơn = giống bolero)</label>
            <input id="loi" type="range" min="0" max="100" value="55" />
            <span class="pill">Lơi: <span id="loiVal" class="mono">55</span></span>
          </div>
        </div>

        <div class="row">
          <div>
            <label>Humanize (độ “người”)</label>
            <input id="human" type="range" min="0" max="100" value="45" />
            <span class="pill">Human: <span id="humanVal" class="mono">45</span></span>
          </div>
        </div>

        <div class="row">
          <button id="btnHold" class="btn secondary" disabled>Bật Hold (đệm nền)</button>
          <button id="btnStop" class="btn danger" disabled>Stop (tắt tiếng)</button>

          <label class="pill" style="cursor:pointer">
            <input id="metro" type="checkbox" style="transform:scale(1.05)" />
            Metronome
          </label>
        </div>

        <hr />

        <div class="row">
          <div style="flex:1; min-width: 260px">
            <label>Input (dán bài vào đây)</label>
            <textarea id="input"></textarea>
          </div>
        </div>

        <div class="row">
          <button id="btnRender" class="btn secondary" disabled>Render + Bấm hợp âm để đệm</button>
          <button id="btnExample" class="btn secondary">Nạp ví dụ (tone Dm, bolero)</button>
        </div>

        <p class="hint">
          Phím tắt: <span class="kbd">Space</span> = Stop. Gợi ý: bolero mềm nhất thường dùng <b>Nylon</b>.
        </p>
      </div>

      <!-- RIGHT -->
      <div class="card">
        <div class="row">
          <span class="pill">Tone: <span id="metaTone" class="mono">—</span></span>
          <span class="pill">Điệu: <span id="metaStyle" class="mono">—</span></span>
          <span class="pill">Current: <span id="nowChord" class="mono">—</span></span>
          <span class="pill">Pending: <span id="pendingChord" class="mono">—</span></span>
        </div>

        <div class="spacer"></div>
        <div id="song" class="song">
          <p class="muted">Bấm “Render…” để hiện lời + hợp âm clickable.</p>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ------------------------------
  // Instrument catalog (dynamic load)
  // ------------------------------
  const BASE = "https://surikov.github.io/webaudiofontdata/sound/";
  const INSTRUMENTS = {
    nylon_lk:   { label:"Acoustic Nylon — LK",      file:"0240_LK_Godin_Nylon_SF2_file.js",   varName:"_tone_0240_LK_Godin_Nylon_SF2_file" },
    steel_lk:   { label:"Acoustic Steel — LK",      file:"0250_LK_AcousticSteel_SF2_file.js", varName:"_tone_0250_LK_AcousticSteel_SF2_file" },
    steel_std:  { label:"Acoustic Steel — Standard",file:"0250_Acoustic_Guitar_sf2_file.js",  varName:"_tone_0250_Acoustic_Guitar_sf2_file" },
    elec_clean: { label:"Electric Clean — Aspirin", file:"0270_Aspirin_sf2_file.js",          varName:"_tone_0270_Aspirin_sf2_file" },
    elec_jazz:  { label:"Electric Jazz — Aspirin",  file:"0260_Aspirin_sf2_file.js",          varName:"_tone_0260_Aspirin_sf2_file" },
    elec_muted: { label:"Electric Muted — Aspirin", file:"0280_Aspirin_sf2_file.js",          varName:"_tone_0280_Aspirin_sf2_file" },
  };

  // ------------------------------
  // DOM
  // ------------------------------
  const $ = (s) => document.querySelector(s);
  const el = {
    btnEnable: $("#btnEnable"),
    btnLoadPreset: $("#btnLoadPreset"),
    presetSel: $("#presetSel"),
    presetState: $("#presetState"),
    audioState: $("#audioState"),

    bpm: $("#bpm"),
    bpmVal: $("#bpmVal"),
    btnTap: $("#btnTap"),

    loi: $("#loi"),
    loiVal: $("#loiVal"),
    human: $("#human"),
    humanVal: $("#humanVal"),

    btnHold: $("#btnHold"),
    holdState: $("#holdState"),
    btnStop: $("#btnStop"),
    metro: $("#metro"),

    input: $("#input"),
    btnRender: $("#btnRender"),
    btnExample: $("#btnExample"),

    metaTone: $("#metaTone"),
    metaStyle: $("#metaStyle"),
    nowChord: $("#nowChord"),
    pendingChord: $("#pendingChord"),
    song: $("#song"),
  };

  // ------------------------------
  // Audio engine
  // ------------------------------
  const AudioContextFunc = window.AudioContext || window.webkitAudioContext;
  let ctx = null;
  let player = null;
  let preset = null;

  let masterGain, compressor, hp, lp, convolver, wetGain, dryGain, outGain;

  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
  function randSigned(){ return (Math.random()*2 - 1); }

  function makeImpulseResponse(context, seconds = 1.2, decay = 3.6) {
    const rate = context.sampleRate;
    const length = Math.max(1, Math.floor(rate * seconds));
    const ir = context.createBuffer(2, length, rate);
    for (let ch = 0; ch < 2; ch++) {
      const data = ir.getChannelData(ch);
      for (let i = 0; i < length; i++) {
        const t = i / length;
        const env = Math.pow(1 - t, decay);
        data[i] = (Math.random() * 2 - 1) * env;
      }
    }
    return ir;
  }

  async function ensureAudio() {
    if (!ctx) {
      ctx = new AudioContextFunc();
      player = new WebAudioFontPlayer();

      masterGain = ctx.createGain();
      masterGain.gain.value = 0.95;

      compressor = ctx.createDynamicsCompressor();
      // Giảm nén để hợp âm “đỡ phẳng”, phân biệt rõ hơn
      compressor.threshold.value = -28;
      compressor.knee.value = 18;
      compressor.ratio.value = 2.2;
      compressor.attack.value = 0.010;
      compressor.release.value = 0.20;

      hp = ctx.createBiquadFilter();
      hp.type = "highpass";
      hp.frequency.value = 80;
      hp.Q.value = 0.7;

      lp = ctx.createBiquadFilter();
      lp.type = "lowpass";
      lp.frequency.value = 9000;
      lp.Q.value = 0.7;

      convolver = ctx.createConvolver();
      convolver.buffer = makeImpulseResponse(ctx);

      wetGain = ctx.createGain();
      wetGain.gain.value = 0.16;

      dryGain = ctx.createGain();
      dryGain.gain.value = 1.0;

      outGain = ctx.createGain();
      outGain.gain.value = 0.95;

      masterGain.connect(compressor);
      compressor.connect(hp);
      hp.connect(lp);

      lp.connect(dryGain);
      lp.connect(convolver);
      convolver.connect(wetGain);

      dryGain.connect(outGain);
      wetGain.connect(outGain);
      outGain.connect(ctx.destination);
    }

    if (ctx.state !== "running") await ctx.resume();

    el.audioState.textContent = "ON";
    el.btnLoadPreset.disabled = false;
    el.btnRender.disabled = false;
    el.btnTap.disabled = false;
    el.btnHold.disabled = false;
    el.btnStop.disabled = false;
  }

  function loadPresetByKey(key) {
    if (!ctx || !player) return;
    const instr = INSTRUMENTS[key] || INSTRUMENTS.nylon_lk;
    el.presetState.textContent = "loading...";
    const url = BASE + instr.file;
    player.loader.startLoad(ctx, url, instr.varName);
    player.loader.waitLoad(() => {
      preset = window[instr.varName];
      player.loader.decodeAfterLoading(ctx, instr.varName);
      el.presetState.textContent = instr.label;
    });
  }

  // ------------------------------
  // Tempo + metronome
  // ------------------------------
  function secPerBeat() { return 60 / Number(el.bpm.value); }
  function barDur() { return secPerBeat() * 4; } // 4/4
  function human01() { return Number(el.human.value)/100; }
  function loi01() { return Number(el.loi.value)/100; }

  // Tap tempo
  let tapTimes = [];
  el.btnTap.addEventListener("click", () => {
    const t = performance.now();
    tapTimes.push(t);
    if (tapTimes.length > 7) tapTimes.shift();
    if (tapTimes.length >= 3) {
      let sum = 0;
      for (let i = 1; i < tapTimes.length; i++) sum += (tapTimes[i] - tapTimes[i-1]);
      const avgMs = sum / (tapTimes.length - 1);
      const bpm = clamp(Math.round(60000 / avgMs), 55, 200);
      el.bpm.value = String(bpm);
      el.bpmVal.textContent = String(bpm);
      if (ctx && el.metro.checked) startMetronome();
      if (holding) reanchorHold();
    }
  });

  let metroTimer = null;
  function metroClick(when, accent=false) {
    if (!ctx) return;
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = "square";
    o.frequency.setValueAtTime(accent ? 1650 : 1300, when);
    g.gain.setValueAtTime(0.0001, when);
    g.gain.linearRampToValueAtTime(accent ? 0.20 : 0.14, when + 0.002);
    g.gain.exponentialRampToValueAtTime(0.0001, when + 0.04);
    o.connect(g);
    g.connect(ctx.destination);
    o.start(when);
    o.stop(when + 0.06);
  }
  function startMetronome() {
    stopMetronome();
    let next = ctx.currentTime + 0.02;
    let beat = 0;
    const lookahead = 0.12;
    const tick = () => {
      const spb = secPerBeat();
      while (next < ctx.currentTime + lookahead) {
        metroClick(next, (beat % 4 === 0));
        next += spb;
        beat++;
      }
      metroTimer = setTimeout(tick, 25);
    };
    tick();
  }
  function stopMetronome() {
    if (metroTimer) clearTimeout(metroTimer);
    metroTimer = null;
  }

  // ------------------------------
  // Guitar voicings (thế bấm guitar thật) cho các hợp âm hay gặp
  // MIDI: E2=40 A2=45 D3=50 G3=55 B3=59 E4=64
  // ------------------------------
  const GUITAR_VOICINGS = {
    "Dm":  [50, 57, 62, 65],               // xx0231
    "Dm7": [50, 57, 60, 62, 65],           // xx0211
    "Am":  [45, 52, 57, 60, 64],           // x02210
    "Am7": [45, 52, 55, 60, 64],           // x02010
    "Bb":  [46, 53, 58, 62, 65],           // x13331
    "C":   [48, 52, 55, 60, 64],           // x32010
    "F":   [41, 48, 53, 57, 60, 65],       // 133211
    "Gm":  [43, 50, 55, 58, 62, 67],       // 355333
    "G":   [43, 47, 50, 55, 59, 67],       // 320003
    "G7":  [43, 47, 50, 55, 59, 65],       // 320001
    "A7":  [45, 52, 55, 61, 64],           // x02020
    "D7":  [50, 57, 60, 66],               // xx0212
    "Em":  [40, 47, 52, 55, 59, 64],       // 022000
    "E7":  [40, 47, 50, 56, 59, 64],       // 020100
  };

  // Fallback chord parser (để không chết nếu gặp hợp âm lạ)
  const NOTE = { C:0, D:2, E:4, F:5, G:7, A:9, B:11 };
  function parseChordSymbol(symRaw) {
    const sym = symRaw.trim().replace("Δ","maj");
    let main = sym, slash = null;
    const slashIdx = sym.indexOf("/");
    if (slashIdx >= 0) { main = sym.slice(0, slashIdx).trim(); slash = sym.slice(slashIdx + 1).trim(); }

    const m = main.match(/^([A-G])([#b]?)(.*)$/);
    if (!m) return { ok:false, sym };

    const root = m[1];
    const acc = m[2] || "";
    let qual = (m[3] || "").trim();

    let triad = "maj";
    let add7 = null; // "min7" or "maj7"
    let sus = null;
    let dim = false, aug = false;

    if (/sus2/i.test(qual)) sus = 2;
    if (/sus4/i.test(qual)) sus = 4;
    if (/dim|o/i.test(qual)) dim = true;
    if (/aug|\+/i.test(qual)) aug = true;

    if (/^m(?!aj)/i.test(qual) || /^min/i.test(qual)) triad = "min";
    if (/maj7/i.test(qual)) add7 = "maj7";
    else if (/m7/i.test(qual)) add7 = "min7";
    else if (/7/.test(qual)) add7 = "min7";

    const rootSemitone = (NOTE[root] + (acc === "#" ? 1 : acc === "b" ? -1 : 0) + 12) % 12;

    let slashSemitone = null;
    if (slash) {
      const sm = slash.match(/^([A-G])([#b]?)$/);
      if (sm) slashSemitone = (NOTE[sm[1]] + (sm[2] === "#" ? 1 : sm[2] === "b" ? -1 : 0) + 12) % 12;
    }

    return { ok:true, sym, rootSemitone, triad, sus, dim, aug, add7, slashSemitone };
  }

  // “Guitar-friendly” fallback voicing (đỡ giống nhau hơn kiểu piano)
  function buildFallbackVoicing(sym) {
    const c = parseChordSymbol(sym);
    if (!c.ok) return [48, 52, 55, 60, 64];

    // Root around A2..D3 area
    let rootMidi = 45 + c.rootSemitone;      // 45..56
    if (rootMidi > 52) rootMidi -= 12;       // clamp to 40..52-ish

    let i3 = 4, i5 = 7;
    if (c.dim) { i3 = 3; i5 = 6; }
    else if (c.aug) { i3 = 4; i5 = 8; }
    else if (c.sus === 2) { i3 = 2; i5 = 7; }
    else if (c.sus === 4) { i3 = 5; i5 = 7; }
    else if (c.triad === "min") { i3 = 3; i5 = 7; }

    // Bass: slash hoặc root-12
    let bass = (c.slashSemitone != null) ? (45 + c.slashSemitone) : (rootMidi - 12);
    bass = clamp(bass, 40, 52);

    const notes = [bass, rootMidi, rootMidi + i3, rootMidi + i5, rootMidi + 12];
    if (c.add7) {
      const i7 = (c.add7 === "maj7") ? 11 : 10;
      notes.push(rootMidi + i7);
    }
    const uniq = Array.from(new Set(notes.map(n => Math.round(n)))).sort((a,b)=>a-b);
    return uniq.length > 6 ? [uniq[0], uniq[2], uniq[3], uniq[4], uniq[5], uniq[uniq.length-1]] : uniq;
  }

  function buildVoicing(sym) {
    const s = sym.trim();
    if (GUITAR_VOICINGS[s]) return GUITAR_VOICINGS[s];
    return buildFallbackVoicing(s);
  }

  function bassPitchForChord(sym) {
    const v = buildVoicing(sym);
    let b = v[0] ?? 45;
    if (b >= 48) b -= 12;
    return clamp(b, 40, 52);
  }

  // ------------------------------
  // Custom strum (rải từng “dây”) — giống tay người hơn queueStrumDown
  // ------------------------------
  function strumCustom(chordSym, when, dir, dur, vol, muted=false) {
    if (!ctx || !player || !preset) return;

    const pitches = buildVoicing(chordSym);
    const order = (dir === "up") ? [...pitches].reverse() : pitches;

    // Spread theo BPM + “lơi”
    const spb = secPerBeat();
    const loi = loi01();     // 0..1
    const h = human01();     // 0..1

    // Ở bolero nên spread lớn hơn (chậm hơn) để đỡ “vội”
    const spread = clamp(spb * (0.018 + 0.030 * loi), 0.016, 0.055); // ~16–55ms
    const jitter = clamp(spb * (0.001 + 0.010 * h), 0.001, 0.010);

    // Muted “chát” -> duration ngắn hơn
    const noteDur = muted ? clamp(dur * 0.35, 0.10, 0.45) : dur;

    order.forEach((p, i) => {
      const t = when + i * spread + randSigned() * jitter;
      const v = clamp(vol * (1 - 0.07 * i) + randSigned() * (0.06 * h), 0.18, 0.95);
      player.queueWaveTable(ctx, masterGain, preset, t, p, noteDur, v);
    });
  }

  // ------------------------------
  // Bolero pattern — 4 hit / 1 ô (đỡ vội, nghe “điềm” hơn)
  // ------------------------------
  const BOLERO_4HIT = [
    {t:0.00, type:"bass", v:0.95}, // 1
    {t:0.25, type:"chat", v:0.55}, // 2
    {t:0.50, type:"bass", v:0.88}, // 3
    {t:0.75, type:"chat", v:0.52}, // 4
  ];

  function scheduleOneBarBolero(chordSym, barStart) {
    if (!ctx || !player || !preset) return;
    const dur = barDur();
    const spb = secPerBeat();
    const h = human01();

    const jitter = clamp(spb * (0.001 + 0.008 * h), 0.001, 0.010);

    for (const ev of BOLERO_4HIT) {
      const t = barStart + ev.t * dur + randSigned() * jitter;
      const v = clamp(ev.v + randSigned() * (0.10 * h), 0.20, 0.95);

      if (ev.type === "bass") {
        const bass = bassPitchForChord(chordSym);
        player.queueWaveTable(ctx, masterGain, preset, t, bass, clamp(0.38, 0.18, 0.55), v);
      } else {
        // “chát” ngắn (muted=true), rải chậm vừa đủ
        strumCustom(chordSym, t, "down", dur * 0.95, v, true);
      }
    }
  }

  // One-shot: click chord -> phát 1 ô (không Hold)
  // Để đỡ “dính bùn” khi click nhanh, ta cancelQueue nếu click quá sát nhau
  let lastOneShotAt = 0;
  function playOneShotBar(chordSym) {
    if (!ctx || !preset) return;

    const now = ctx.currentTime;
    const minGap = clamp(barDur() * 0.35, 0.25, 0.80); // click sát quá -> dọn queue
    if (now - lastOneShotAt < minGap) {
      player.cancelQueue(ctx);
    }
    lastOneShotAt = now;

    const start = now + 0.03;
    scheduleOneBarBolero(chordSym, start);
  }

  // ------------------------------
  // Hold mode: loop bars + quantized chord change at bar boundary
  // ------------------------------
  let holdOn = false;
  let holding = false;
  let currentChord = null;
  let pendingChord = null;

  let schedTimer = null;
  let nextBarTime = 0;

  function setNowChord(sym) {
    currentChord = sym;
    el.nowChord.textContent = sym || "—";
  }
  function setPendingChord(sym) {
    pendingChord = sym;
    el.pendingChord.textContent = sym || "—";
  }

  function reanchorHold() {
    // khi đổi BPM, re-anchor để đỡ lệch nhịp cảm giác
    nextBarTime = ctx.currentTime + 0.10;
  }

  function startHoldLoop(initialChord) {
    if (!ctx || !preset) return;
    holding = true;
    setNowChord(initialChord);
    setPendingChord(null);

    nextBarTime = ctx.currentTime + 0.10;

    const lookahead = 0.22;
    const tick = () => {
      if (!holding) return;

      while (nextBarTime < ctx.currentTime + lookahead) {
        if (pendingChord) {
          setNowChord(pendingChord);
          setPendingChord(null);
        }
        scheduleOneBarBolero(currentChord, nextBarTime);
        nextBarTime += barDur();
      }
      schedTimer = setTimeout(tick, 25);
    };
    tick();
  }

  function stopAll() {
    holding = false;
    holdOn = false;
    el.holdState.textContent = "OFF";
    el.btnHold.textContent = "Bật Hold (đệm nền)";

    if (schedTimer) clearTimeout(schedTimer);
    schedTimer = null;

    if (player && ctx) player.cancelQueue(ctx);
    setNowChord(null);
    setPendingChord(null);

    if (el.metro.checked) {
      el.metro.checked = false;
      stopMetronome();
    }
  }

  // ------------------------------
  // Rendering chord sheet to clickable UI
  // ------------------------------
  function parseMetadata(text) {
    const tone = (text.match(/^\s*Tone:\s*(.+)\s*$/mi) || [])[1]?.trim() || "—";
    const style = (text.match(/^\s*Điệu:\s*(.+)\s*$/mi) || [])[1]?.trim() || "—";
    return { tone, style };
  }

  function isSectionTitle(line) {
    return /^\s*(Intro:|ĐK:|DK:|Điệp khúc:|Chorus:|Verse\s*\d+|Bridge:|\d+\.)/i.test(line.trim());
  }

  function renderSong(text) {
    const { tone, style } = parseMetadata(text);
    el.metaTone.textContent = tone;
    el.metaStyle.textContent = style;

    const lines = text.replace(/\r/g, "").split("\n");
    const container = document.createElement("div");

    for (const rawLine of lines) {
      const line = rawLine.trimEnd();

      if (!line.trim()) {
        const spacer = document.createElement("div");
        spacer.className = "line";
        spacer.style.borderBottom = "none";
        spacer.innerHTML = "&nbsp;";
        container.appendChild(spacer);
        continue;
      }

      // Skip metadata lines from rendering body
      if (/^\s*Tone\s*:/i.test(line) || /^\s*Điệu\s*:/i.test(line)) continue;

      const div = document.createElement("div");
      div.className = "line";

      if (isSectionTitle(line)) {
        const t = document.createElement("div");
        t.className = "sectionTitle";
        t.textContent = line;
        div.appendChild(t);
        container.appendChild(div);
        continue;
      }

      // Tokenize [Chord]
      const parts = [];
      const re = /\[([^\]]+)\]/g;
      let lastIdx = 0;
      let m;
      while ((m = re.exec(line)) !== null) {
        const before = line.slice(lastIdx, m.index);
        if (before) parts.push({ type:"text", value: before });
        parts.push({ type:"chord", value: m[1].trim() });
        lastIdx = m.index + m[0].length;
      }
      const tail = line.slice(lastIdx);
      if (tail) parts.push({ type:"text", value: tail });

      for (const p of parts) {
        if (p.type === "text") {
          div.appendChild(document.createTextNode(p.value));
        } else {
          const sp = document.createElement("span");
          sp.className = "chord";
          sp.textContent = p.value;
          sp.dataset.chord = p.value;

          sp.addEventListener("click", async () => {
            await ensureAudio();
            if (!preset) loadPresetByKey(el.presetSel.value);

            document.querySelectorAll(".chord.active").forEach(x => x.classList.remove("active"));
            sp.classList.add("active");

            if (holdOn) {
              if (!holding) startHoldLoop(p.value);
              else setPendingChord(p.value);
            } else {
              setNowChord(p.value);
              setPendingChord(null);
              playOneShotBar(p.value);
            }
          });

          div.appendChild(sp);
        }
      }

      container.appendChild(div);
    }

    el.song.innerHTML = "";
    el.song.appendChild(container);
  }

  // ------------------------------
  // UI wiring
  // ------------------------------
  el.bpm.addEventListener("input", () => {
    el.bpmVal.textContent = el.bpm.value;
    if (ctx && el.metro.checked) startMetronome();
    if (holding) reanchorHold();
  });

  el.loi.addEventListener("input", () => { el.loiVal.textContent = el.loi.value; });
  el.human.addEventListener("input", () => { el.humanVal.textContent = el.human.value; });

  el.btnEnable.addEventListener("click", async () => {
    await ensureAudio();
    loadPresetByKey(el.presetSel.value);
  });

  el.btnLoadPreset.addEventListener("click", async () => {
    await ensureAudio();
    loadPresetByKey(el.presetSel.value);
  });

  el.presetSel.addEventListener("change", () => {
    if (ctx) loadPresetByKey(el.presetSel.value);
  });

  el.btnRender.addEventListener("click", async () => {
    await ensureAudio();
    renderSong(el.input.value);
  });

  el.btnExample.addEventListener("click", () => {
    el.input.value = EXAMPLE;
    if (ctx) renderSong(el.input.value);
  });

  el.btnHold.addEventListener("click", async () => {
    await ensureAudio();
    holdOn = !holdOn;
    el.holdState.textContent = holdOn ? "ON" : "OFF";
    el.btnHold.textContent = holdOn ? "Tắt Hold (đệm nền)" : "Bật Hold (đệm nền)";

    if (!holdOn && holding) {
      holding = false;
      if (schedTimer) clearTimeout(schedTimer);
      schedTimer = null;
      setPendingChord(null);
    }
  });

  el.btnStop.addEventListener("click", () => stopAll());

  el.metro.addEventListener("change", async () => {
    await ensureAudio();
    if (el.metro.checked) startMetronome();
    else stopMetronome();
  });

  window.addEventListener("keydown", (e) => {
    if (e.code === "Space") {
      e.preventDefault();
      stopAll();
    }
  });

  document.addEventListener("visibilitychange", () => {
    if (document.hidden) stopAll();
  });

  // ------------------------------
  // Example input (your sample)
  // ------------------------------
  const EXAMPLE =
`Tone: Dm
Điệu: Bolero

Intro: [Dm] [F] [C] [Dm] - [Bb] [C] [F] [Gm] - [Bb] [Am] [Dm] [Am7]

1. Say giấc mộng ban [Dm] đầu yêu [Bb] người thủa mới đôi [F] mươi em [C] đang độ trăng [Dm] tròn
Từng ngày qua [Bb] phố áo [C] em trắng cả đường [F] về
Lá [Gm] thư ướp mộng học [Bb] trò mối [Am]tình xanh như khúc [F] hát. [Dm7] [Am7]

2. Ai đã hẹn với [Dm] thề để [Bb] rồi lỡ mối duyên [F] thơ ra [C] đi chẳng giã [Dm] từ
Ngày em thay [Bb] áo áo [C] hoa pháo đỏ rượu [F] nồng
Có [Gm] ai nát cả cõi [Bb] lòng đứng [Am]nhìn em bước bên [Dm] chồng.

ĐK: Hai mươi [C] năm [Am] cuộc mộng dở [Dm] dang khắc sâu bóng [F] nàng
Lắng trong cung [Dm] đàn [C] em giờ ở [Dm]đâu hẳn vui duyên [F] mới
Hai mươi [C] năm [Am] cuộc rượu còn [Dm]đây uống qua tháng [F] ngày
Cố quên đi [Bb] người say [Am] hoài sầu không [Dm] vơi
Tình duyên ta [F] tiếc [Am] uống thêm ly [Dm]này.

3. [Am7] Ôm giấc mộng lỡ [Dm] làng những [Bb] chiều lắng tiếng mưa [F] rơi đêm [C] say chờ trăng [Dm] tàn
Từng thu thay [Bb] lá, lá [C] rơi đắp mộ cuộc [F] tình
Lá [Gm] bay chất nặng tuổi [Bb] đời nhớ [Am]người ta rót ly [Dm] này.`;

  el.input.value = EXAMPLE;
  el.bpmVal.textContent = el.bpm.value;
  el.loiVal.textContent = el.loi.value;
  el.humanVal.textContent = el.human.value;

})();
</script>
</body>
</html>