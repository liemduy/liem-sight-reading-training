<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Guitar Accompaniment (Singer Mode) — Soundfont Player</title>
  <!-- Library (CDN): soundfont-player -->
  <script src="https://cdn.jsdelivr.net/npm/soundfont-player@0.12.0/dist/soundfont-player.min.js"></script>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; line-height: 1.35; }
    .grid { display: grid; gap: 12px; grid-template-columns: 1fr; max-width: 980px; }
    @media (min-width: 900px) { .grid { grid-template-columns: 1.2fr 0.8fr; } }
    .card { border: 1px solid rgba(128,128,128,.35); border-radius: 10px; padding: 12px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .row3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
    label { display: grid; gap: 6px; font-size: 13px; opacity: .95; }
    input[type="text"], input[type="number"], textarea, select {
      width: 100%; padding: 10px; border-radius: 8px; border: 1px solid rgba(128,128,128,.35);
      background: transparent; color: inherit;
    }
    textarea { min-height: 140px; resize: vertical; }
    input[type="range"] { width: 100%; }
    button {
      padding: 10px 12px; border-radius: 8px; border: 1px solid rgba(128,128,128,.35);
      background: rgba(128,128,128,.12); color: inherit; cursor: pointer;
    }
    button.primary { background: rgba(0,128,255,.18); border-color: rgba(0,128,255,.35); }
    button:disabled { opacity: .55; cursor: not-allowed; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 12px; }
    .status { white-space: pre-wrap; padding: 10px; border-radius: 8px; border: 1px dashed rgba(128,128,128,.45); }
    .pill { display:inline-block; padding: 3px 8px; border-radius: 999px; border: 1px solid rgba(128,128,128,.35); font-size: 12px; opacity: .9; }
    .small { font-size: 12px; opacity: .85; }
  </style>
</head>

<body>
  <h2>Guitar accompaniment (đệm hát “Singer Mode”)</h2>
  <div class="small">
    Thư viện âm thanh: <span class="pill">soundfont-player</span>
    <span class="pill">Web Audio</span>
    <span class="pill">MP3-only (không chạm .ogg)</span>
  </div>

  <div class="grid">
    <div class="card">
      <h3>Progression</h3>
      <label>
        Chord progression (phân tách bằng dấu <span class="mono">|</span> hoặc xuống dòng). Ví dụ: <span class="mono">C | G | Am | F</span>
        <textarea id="prog">C | G | Am | F
Dm7 | G7 | Cmaj7 | Cmaj7</textarea>
      </label>

      <div class="row">
        <label>
          Tempo (BPM)
          <input id="bpm" type="number" min="40" max="220" value="84" />
        </label>
        <label>
          Pattern
          <select id="pattern">
            <option value="strum8">Strum 8ths (pop)</option>
            <option value="strum16lite">Strum 16ths (lite)</option>
            <option value="arp8">Arp 8ths (fingerstyle)</option>
            <option value="bossa">Bossa (nhẹ)</option>
          </select>
        </label>
      </div>

      <div class="row">
        <label>
          Slider: Normal → Singer Mode
          <input id="singer" type="range" min="0" max="100" value="70" />
          <div class="small"><span id="singerLabel">70</span>%</div>
        </label>

        <label>
          Swing (0–60%)
          <input id="swing" type="range" min="0" max="60" value="10" />
          <div class="small"><span id="swingLabel">10</span>%</div>
        </label>
      </div>

      <div class="row3">
        <label>
          Instrument
          <select id="inst">
            <option value="acoustic_guitar_nylon" selected>Acoustic Guitar (Nylon)</option>
            <option value="acoustic_guitar_steel">Acoustic Guitar (Steel)</option>
          </select>
        </label>

        <label>
          Soundfont set
          <select id="sfset">
            <option value="MusyngKite" selected>MusyngKite (hay hơn, nặng hơn)</option>
            <option value="FluidR3_GM">FluidR3_GM (nhẹ hơn)</option>
          </select>
        </label>

        <label>
          Guitar output gain
          <input id="outGain" type="range" min="0" max="100" value="68" />
          <div class="small"><span id="outGainLabel">68</span>%</div>
        </label>
      </div>

      <div class="row">
        <label>
          Mic ducking (nhường cho ca sĩ)
          <select id="duck">
            <option value="off" selected>Tắt</option>
            <option value="on">Bật (xin quyền micro)</option>
          </select>
          <div class="small">Bật ducking sẽ tự giảm guitar nhẹ khi mic có tín hiệu.</div>
        </label>

        <label>
          “Anti-pull” level
          <input id="antipull" type="range" min="0" max="100" value="65" />
          <div class="small"><span id="antipullLabel">65</span>%</div>
        </label>
      </div>

      <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top: 10px;">
        <button class="primary" id="btnStart">Start Audio / Load</button>
        <button id="btnPlay" disabled>Play</button>
        <button id="btnStop" disabled>Stop</button>
        <button id="btnTest" disabled>Test strum</button>
      </div>

      <div class="status mono" id="status">Ready.</div>
    </div>

    <div class="card">
      <h3>Implementation notes (tóm tắt logic)</h3>
      <ul class="small">
        <li><b>Không dùng Tone.js</b>. Dùng <span class="mono">soundfont-player</span> qua CDN + Web Audio graph riêng.</li>
        <li><b>Không dùng .ogg</b>: ép <span class="mono">format: "mp3"</span> khi load instrument.</li>
        <li><b>Singer Mode</b> nội suy: density ↓, accent ↓, voicing lên cao & gọn, strum mềm + “nhường” (duck/antipull) ↑.</li>
        <li><b>Subdivision</b>: scheduler lookahead + swing + microtiming có kiểm soát (không random trắng).</li>
        <li><b>Chống kéo ca sĩ</b>: giảm transient + giảm lowmid (EQ) + ducking theo mic (nếu bật).</li>
      </ul>

      <h3>Debug</h3>
      <label class="small">
        Last scheduled events
        <div class="status mono" id="debug">—</div>
      </label>
    </div>
  </div>

<script>
(() => {
  // ---------- UI ----------
  const $ = (id) => document.getElementById(id);
  const statusEl = $("status");
  const debugEl = $("debug");

  const ui = {
    prog: $("prog"),
    bpm: $("bpm"),
    pattern: $("pattern"),
    singer: $("singer"),
    singerLabel: $("singerLabel"),
    swing: $("swing"),
    swingLabel: $("swingLabel"),
    inst: $("inst"),
    sfset: $("sfset"),
    outGain: $("outGain"),
    outGainLabel: $("outGainLabel"),
    duck: $("duck"),
    antipull: $("antipull"),
    antipullLabel: $("antipullLabel"),
    btnStart: $("btnStart"),
    btnPlay: $("btnPlay"),
    btnStop: $("btnStop"),
    btnTest: $("btnTest"),
  };

  function log(msg) {
    statusEl.textContent = msg;
  }

  function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
  function lerp(a, b, t) { return a + (b - a) * t; }
  function nowMs() { return (typeof performance !== "undefined" ? performance.now() : Date.now()); }

  function norm01FromSlider(sliderEl) { return clamp(Number(sliderEl.value) / 100, 0, 1); }

  function updateLabels() {
    ui.singerLabel.textContent = ui.singer.value;
    ui.swingLabel.textContent = ui.swing.value;
    ui.outGainLabel.textContent = ui.outGain.value;
    ui.antipullLabel.textContent = ui.antipull.value;
  }
  ["input","change"].forEach(evt => {
    ui.singer.addEventListener(evt, updateLabels);
    ui.swing.addEventListener(evt, updateLabels);
    ui.outGain.addEventListener(evt, updateLabels);
    ui.antipull.addEventListener(evt, updateLabels);
  });
  updateLabels();

  // ---------- Audio core ----------
  let ac = null;
  let instrument = null;

  // Output chain
  let out = {
    preGain: null,
    hp: null,
    presence: null,
    softLP: null,
    duckGain: null,
    reverbSend: null,
    reverbReturn: null,
    master: null,
  };

  // Mic ducking
  let mic = {
    stream: null,
    source: null,
    analyser: null,
    data: null,
    env: 0,
    lastT: 0,
    raf: 0,
  };

  // Transport / scheduler
  let transport = {
    isPlaying: false,
    lookaheadMs: 25,
    scheduleAheadSec: 0.20,
    timer: 0,
    nextTime: 0,
    stepIndex: 0,
    progression: [],
    chordIndex: 0,
    barSteps: 16, // treat 1 bar = 16th grid (4/4)
    chordPerBar: 1, // default: 1 chord per bar
  };

  function ensureAudioContext() {
    if (ac) return ac;
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    ac = new AudioCtx({ latencyHint: "interactive" });

    // Build output chain (lightweight but musical)
    out.preGain = ac.createGain();
    out.hp = ac.createBiquadFilter();
    out.hp.type = "highpass";
    out.hp.frequency.value = 70;
    out.hp.Q.value = 0.707;

    out.presence = ac.createBiquadFilter();
    out.presence.type = "peaking";
    out.presence.frequency.value = 3200;
    out.presence.Q.value = 0.9;
    out.presence.gain.value = 1.5;

    out.softLP = ac.createBiquadFilter();
    out.softLP.type = "lowpass";
    out.softLP.frequency.value = 12000;
    out.softLP.Q.value = 0.707;

    out.duckGain = ac.createGain();
    out.duckGain.gain.value = 1.0;

    // Tiny reverb: dual delay feedback network (very light; not convolution)
    const d1 = ac.createDelay(1.0);
    const d2 = ac.createDelay(1.0);
    d1.delayTime.value = 0.071;
    d2.delayTime.value = 0.113;

    const fb1 = ac.createGain();
    const fb2 = ac.createGain();
    fb1.gain.value = 0.18;
    fb2.gain.value = 0.16;

    const rvLP = ac.createBiquadFilter();
    rvLP.type = "lowpass";
    rvLP.frequency.value = 5200;

    out.reverbSend = ac.createGain();
    out.reverbReturn = ac.createGain();
    out.reverbSend.gain.value = 0.20;
    out.reverbReturn.gain.value = 0.32;

    // routing
    out.preGain.connect(out.hp);
    out.hp.connect(out.presence);
    out.presence.connect(out.softLP);
    out.softLP.connect(out.duckGain);
    out.duckGain.connect(out.reverbSend);
    out.duckGain.connect(ac.destination);

    // reverb loop
    out.reverbSend.connect(d1);
    d1.connect(rvLP);
    rvLP.connect(d2);
    d2.connect(out.reverbReturn);
    out.reverbReturn.connect(ac.destination);

    // feedback
    d1.connect(fb1);
    fb1.connect(d1);
    d2.connect(fb2);
    fb2.connect(d2);

    // Master gain (via preGain for simplicity)
    setOutputGain(norm01FromSlider(ui.outGain));

    return ac;
  }

  function setOutputGain(x01) {
    if (!ac || !out.preGain) return;
    // perceptual-ish curve
    const g = Math.pow(x01, 1.6);
    out.preGain.gain.setTargetAtTime(g, ac.currentTime, 0.01);
  }

  async function unlockAudio() {
    const ctx = ensureAudioContext();
    if (ctx.state !== "running") {
      await ctx.resume();
    }
  }

  async function loadInstrument() {
    const ctx = ensureAudioContext();
    const name = ui.inst.value;
    const set = ui.sfset.value;

    log("Loading instrument...");
    instrument = await window.Soundfont.instrument(ctx, name, {
      soundfont: set,
      format: "mp3",          // critical: avoid .ogg on iOS and “network filter .ogg”
      destination: out.preGain,
      // Performance: decode only the notes we’ll likely use (rough range)
      // You can widen this if you want more realism.
      notes: buildPrefetchNotes(40, 76),
      // Softer default envelope; we will modulate per note.
      attack: 0.002,
      release: 0.18,
      gain: 0.9
    });

    log(`Loaded: ${name} (${set}, mp3).`);
    ui.btnPlay.disabled = false;
    ui.btnTest.disabled = false;
  }

  function buildPrefetchNotes(loMidi, hiMidi) {
    const notes = [];
    for (let m = loMidi; m <= hiMidi; m++) notes.push(m);
    return notes;
  }

  // ---------- Chord parsing / voicing ----------
  const NOTE_TO_PC = {
    "C":0,"C#":1,"Db":1,"D":2,"D#":3,"Eb":3,"E":4,"F":5,"F#":6,"Gb":6,"G":7,"G#":8,"Ab":8,"A":9,"A#":10,"Bb":10,"B":11
  };

  function parseProgression(text) {
    // Accept "|" or newline separators. Also tolerate extra spaces.
    const raw = text
      .replace(/\r/g, "")
      .split(/\n|[|]/g)
      .map(s => s.trim())
      .filter(Boolean);

    // Default: 1 chord per bar. If user writes "C x2", we interpret repeats.
    const seq = [];
    for (const token of raw) {
      const m = token.match(/^(.+?)\s*x\s*(\d+)$/i);
      if (m) {
        const chord = m[1].trim();
        const n = clamp(parseInt(m[2], 10) || 1, 1, 64);
        for (let i = 0; i < n; i++) seq.push(chord);
      } else {
        seq.push(token);
      }
    }
    return seq;
  }

  function chordToPitchClasses(symbol) {
    // Very practical subset for accompaniment:
    // Root: C, F#, Bb...
    // Quality: maj, m/min, dim, aug, sus2, sus4
    // 7th: 7, maj7, m7
    // Added: add9, 6
    const s = symbol.trim();

    const rootMatch = s.match(/^([A-G])(#{1}|b{1})?/);
    if (!rootMatch) return null;

    const rootName = rootMatch[1] + (rootMatch[2] || "");
    const rootPc = NOTE_TO_PC[rootName];
    if (rootPc == null) return null;

    const rest = s.slice(rootMatch[0].length).trim().toLowerCase();

    // Defaults
    let third = 4; // major
    let fifth = 7;
    let seventh = null;
    let add9 = false;
    let sixth = null;
    let sus = null;

    // Detect basic quality
    if (rest.startsWith("m") && !rest.startsWith("maj")) third = 3; // m, min
    if (rest.includes("dim") || rest.includes("o")) { third = 3; fifth = 6; }
    if (rest.includes("aug") || rest.includes("+")) { third = 4; fifth = 8; }

    if (rest.includes("sus2")) { sus = 2; }
    else if (rest.includes("sus4") || rest.includes("sus")) { sus = 5; }

    if (rest.includes("maj7") || rest.includes("ma7")) seventh = 11;
    else if (rest.includes("m7") || rest.includes("min7")) seventh = 10;
    else if (rest.includes("7")) seventh = 10;

    if (rest.includes("add9")) add9 = true;
    if (rest.includes("6") && !rest.includes("16")) sixth = 9;

    const pcs = [];
    pcs.push(rootPc);

    if (sus != null) pcs.push((rootPc + sus) % 12);
    else pcs.push((rootPc + third) % 12);

    pcs.push((rootPc + fifth) % 12);

    if (sixth != null) pcs.push((rootPc + sixth) % 12);
    if (seventh != null) pcs.push((rootPc + seventh) % 12);
    if (add9) pcs.push((rootPc + 2) % 12);

    // unique + stable order
    const uniq = [];
    for (const pc of pcs) if (!uniq.includes(pc)) uniq.push(pc);
    return uniq;
  }

  function voiceChord(pitchClasses, opts) {
    // opts:
    // - centerMidi: where to place chord
    // - maxNotes
    // - includeBass
    // - bassMidi
    // - spread: how wide to stack
    const center = opts.centerMidi;
    const maxNotes = opts.maxNotes;

    // build chord tones across octaves near center
    const candidates = [];
    for (let oct = -2; oct <= 3; oct++) {
      for (const pc of pitchClasses) {
        const m = pc + 12 * (Math.floor(center / 12) + oct);
        if (m >= 30 && m <= 88) candidates.push(m);
      }
    }
    candidates.sort((a,b) => a-b);

    // pick tones closest to center (then de-duplicate pitch class as needed)
    const chosen = [];
    const chosenPCs = new Set();
    const distSorted = candidates
      .map(m => ({ m, d: Math.abs(m - center) }))
      .sort((a,b) => a.d - b.d);

    for (const item of distSorted) {
      const pc = ((item.m % 12) + 12) % 12;
      if (chosenPCs.has(pc) && chosen.length >= 2) continue; // allow some doubling only early
      chosen.push(item.m);
      chosenPCs.add(pc);
      if (chosen.length >= maxNotes) break;
    }

    chosen.sort((a,b) => a-b);

    if (opts.includeBass) {
      const rootPc = pitchClasses[0];
      let bass = opts.bassMidi;
      // snap bass to root pitch-class near bassMidi
      const bassCandidates = [];
      for (let k = -2; k <= 2; k++) {
        const m = rootPc + 12 * (Math.floor(bass / 12) + k);
        if (m >= 28 && m <= 55) bassCandidates.push(m);
      }
      bassCandidates.sort((a,b) => Math.abs(a-bass) - Math.abs(b-bass));
      const bassNote = bassCandidates[0] ?? (rootPc + 36);
      // Ensure bass is below chord
      if (bassNote < chosen[0]) chosen.unshift(bassNote);
      else chosen.unshift(Math.max(28, chosen[0] - 12));
    }

    return chosen;
  }

  // ---------- Musical policy (Normal ↔ Singer Mode) ----------
  function computePolicy() {
    const singer = norm01FromSlider(ui.singer);
    const antiPull = norm01FromSlider(ui.antipull);
    const swingPct = clamp(Number(ui.swing.value) / 100, 0, 0.60);

    const bpm = clamp(Number(ui.bpm.value) || 84, 40, 220);
    const beat = 60 / bpm;
    const step16 = beat / 4;

    // Density: in Singer Mode, reduce events
    const density = lerp(1.0, 0.55, singer); // scalar used by patterns

    // Accent: in Singer Mode, reduce downbeat transient
    const accentDown = lerp(1.00, 0.78, singer);
    const accentUp   = lerp(0.82, 0.70, singer);

    // Strum spread: Singer tends to be softer, less “đinh” → slightly more spread (up to ~20ms)
    const strumSpreadSec = lerp(0.010, 0.020, singer);

    // Microtiming: keep controlled; Singer Mode: slightly behind (relaxed)
    const behindSec = lerp(0.000, 0.010, singer * antiPull);

    // Jitter: very small, not white-noise heavy
    const jitterSec = lerp(0.004, 0.006, singer) * 0.9;

    // Voicing
    const maxNotes = Math.round(lerp(5, 3, singer)); // Singer: gọn 3 notes
    const includeBass = singer < 0.45;               // Singer: often skip bass thump unless needed
    const centerMidi = lerp(52, 64, singer);         // Singer: push chord up to avoid vocal body
    const bassMidi = lerp(40, 38, singer);

    // Mix/EQ policy
    // Singer: cut low-mid pressure + soften top-end transient
    const hpHz = lerp(70, 110, singer);
    const lpHz = lerp(12500, 9000, singer * 0.8);
    const presenceDb = lerp(1.8, 0.8, singer);

    // Reverb: Singer slightly more “glue”
    const rvSend = lerp(0.18, 0.24, singer);
    const rvReturn = lerp(0.30, 0.36, singer);

    return {
      bpm, beat, step16,
      singer, antiPull, swingPct,
      density,
      accentDown, accentUp,
      strumSpreadSec,
      behindSec, jitterSec,
      maxNotes, includeBass, centerMidi, bassMidi,
      hpHz, lpHz, presenceDb, rvSend, rvReturn
    };
  }

  function applyMixPolicy(p) {
    if (!ac) return;
    out.hp.frequency.setTargetAtTime(p.hpHz, ac.currentTime, 0.05);
    out.softLP.frequency.setTargetAtTime(p.lpHz, ac.currentTime, 0.05);
    out.presence.gain.setTargetAtTime(p.presenceDb, ac.currentTime, 0.08);
    out.reverbSend.gain.setTargetAtTime(p.rvSend, ac.currentTime, 0.08);
    out.reverbReturn.gain.setTargetAtTime(p.rvReturn, ac.currentTime, 0.08);
    setOutputGain(norm01FromSlider(ui.outGain));
  }

  // ---------- Patterns ----------
  function patternEvents(patternName, stepIndex, p) {
    // Return an array of events within a 16th step:
    // Each event: { kind: "strum"|"arp", dir: "down"|"up", vel: 0..1, durSec, gate: 0..1 }
    const s = stepIndex % 16;
    const events = [];

    // Swing: move even 16ths? We'll apply at scheduling-time only for 8th feel.
    // Here we define rhythms. Density scales by p.density.

    if (patternName === "strum8") {
      // Strong on 1, light on "&" (8ths)
      const on8 = (s === 0 || s === 8);
      const off8 = (s === 4 || s === 12);

      if (on8 && Math.random() < 0.98) {
        events.push({ kind:"strum", dir:"down", vel: 0.92 * p.accentDown, durSec: 0.75, gate: 1.0 });
      }
      if (off8 && Math.random() < (0.88 * p.density)) {
        events.push({ kind:"strum", dir:"up", vel: 0.76 * p.accentUp, durSec: 0.62, gate: 0.9 });
      }
      // occasional ghost upstroke (very soft), reduced in Singer Mode
      if ((s === 2 || s === 10) && Math.random() < (0.16 * (1 - p.singer))) {
        events.push({ kind:"strum", dir:"up", vel: 0.50 * p.accentUp, durSec: 0.35, gate: 0.6 });
      }
    }

    else if (patternName === "strum16lite") {
      // 16ths but controlled; Singer Mode reduces the “in-between”
      const strong = (s === 0 || s === 8);
      const med = (s === 4 || s === 12);
      const lite = (s === 2 || s === 6 || s === 10 || s === 14);

      if (strong) events.push({ kind:"strum", dir:"down", vel: 0.90 * p.accentDown, durSec: 0.70, gate: 1.0 });
      if (med && Math.random() < (0.92 * p.density)) events.push({ kind:"strum", dir:"up", vel: 0.72 * p.accentUp, durSec: 0.55, gate: 0.9 });

      const liteProb = lerp(0.55, 0.12, p.singer) * p.density;
      if (lite && Math.random() < liteProb) {
        events.push({ kind:"strum", dir: (s % 4 === 2 ? "down" : "up"), vel: 0.55, durSec: 0.28, gate: 0.55 });
      }
    }

    else if (patternName === "arp8") {
      // Fingerstyle-ish arpeggio on 8ths: 1 (bass) - & (chord) - 2 (bass) - & (chord)...
      const on8 = (s === 0 || s === 8);
      const off8 = (s === 4 || s === 12);
      if (on8) events.push({ kind:"arp", dir:"down", vel: 0.86 * p.accentDown, durSec: 0.55, gate: 1.0 });
      if (off8 && Math.random() < (0.95 * p.density)) events.push({ kind:"arp", dir:"up", vel: 0.74 * p.accentUp, durSec: 0.48, gate: 0.9 });
    }

    else if (patternName === "bossa") {
      // Very simplified bossa cell (light, singer-friendly)
      // Steps: 0(bass), 6(chord), 8(bass), 14(chord)
      const bass = (s === 0 || s === 8);
      const chord = (s === 6 || s === 14);
      if (bass) events.push({ kind:"arp", dir:"down", vel: 0.78 * p.accentDown, durSec: 0.50, gate: 1.0 });
      if (chord && Math.random() < (0.98 * p.density)) events.push({ kind:"strum", dir:"up", vel: 0.66 * p.accentUp, durSec: 0.52, gate: 0.85 });
    }

    return events;
  }

  // ---------- Timing / swing / humanize ----------
  function applySwingToTime(baseTime, stepIndex, p) {
    // Apply swing to the 8th offbeats (i.e., step 4 and 12) by delaying them
    // Swing amount up to 60% of a 16th.
    const s = stepIndex % 16;
    const is8thOff = (s === 4 || s === 12);
    if (!is8thOff) return baseTime;

    const maxDelay = p.step16 * 0.60;          // cap
    const delay = maxDelay * p.swingPct;       // scaled
    return baseTime + delay;
  }

  function humanizeTime(t, p) {
    // Controlled microtiming: small jitter + singer “behind” feel.
    const jitter = (Math.random() * 2 - 1) * p.jitterSec;
    return t + jitter + p.behindSec;
  }

  // ---------- Scheduling / playback ----------
  function startTransport() {
    if (!instrument || !ac) return;

    transport.isPlaying = true;
    transport.stepIndex = 0;
    transport.chordIndex = 0;

    transport.progression = parseProgression(ui.prog.value);
    if (transport.progression.length === 0) transport.progression = ["C"];

    const p = computePolicy();
    applyMixPolicy(p);

    // Start slightly in the future
    transport.nextTime = ac.currentTime + 0.08;
    transport.timer = window.setInterval(schedulerTick, transport.lookaheadMs);

    ui.btnPlay.disabled = true;
    ui.btnStop.disabled = false;

    log("Playing...");
  }

  function stopTransport() {
    transport.isPlaying = false;
    if (transport.timer) window.clearInterval(transport.timer);
    transport.timer = 0;

    // Stop all currently playing notes in instrument
    try { instrument && instrument.stop && instrument.stop(); } catch (_) {}

    ui.btnPlay.disabled = false;
    ui.btnStop.disabled = true;

    log("Stopped.");
  }

  function currentChordSymbol() {
    const seq = transport.progression;
    if (!seq || seq.length === 0) return "C";
    return seq[transport.chordIndex % seq.length];
  }

  function advanceChordIfNeeded(stepIndex) {
    // 1 chord per bar (16 steps). Customize here if you need 2 chords/bar etc.
    if (stepIndex > 0 && (stepIndex % transport.barSteps === 0)) {
      transport.chordIndex = (transport.chordIndex + 1) % transport.progression.length;
    }
  }

  function schedulerTick() {
    if (!transport.isPlaying) return;
    const p = computePolicy();
    applyMixPolicy(p);

    const horizon = ac.currentTime + transport.scheduleAheadSec;
    const scheduled = [];

    while (transport.nextTime < horizon) {
      advanceChordIfNeeded(transport.stepIndex);

      const chordSym = currentChordSymbol();
      const pcs = chordToPitchClasses(chordSym) || chordToPitchClasses("C");
      const events = patternEvents(ui.pattern.value, transport.stepIndex, p);

      // schedule each event
      for (const ev of events) {
        let t = transport.nextTime;
        t = applySwingToTime(t, transport.stepIndex, p);
        t = humanizeTime(t, p);

        // If antiPull high + singer high, avoid “hard” downbeat by slightly spreading earlier/later
        const soften = p.singer * p.antiPull;
        const vel = clamp(ev.vel * lerp(1.0, 0.92, soften), 0.05, 1.0);

        scheduleEvent(chordSym, pcs, t, ev, p, vel);
        scheduled.push({ t: t.toFixed(3), step: transport.stepIndex, chord: chordSym, kind: ev.kind, dir: ev.dir, vel: vel.toFixed(2) });
      }

      // advance step
      transport.stepIndex++;
      transport.nextTime += p.step16;
    }

    if (scheduled.length) {
      debugEl.textContent = scheduled.slice(-10).map(x =>
        `${x.t}s  step=${String(x.step).padStart(3," ")}  ${x.chord.padEnd(6," ")}  ${x.kind}/${x.dir}  vel=${x.vel}`
      ).join("\n");
    }
  }

  function scheduleEvent(chordSym, pcs, timeSec, ev, p, vel) {
    // Voicing policy
    const isDownbeat = (transport.stepIndex % 16 === 0);
    const includeBass = p.includeBass && isDownbeat && (ev.kind !== "arp");
    const chordNotes = voiceChord(pcs, {
      centerMidi: p.centerMidi,
      maxNotes: p.maxNotes,
      includeBass,
      bassMidi: p.bassMidi,
    });

    if (!chordNotes || chordNotes.length === 0) return;

    // Strum ordering
    const order = (ev.dir === "down")
      ? chordNotes.slice()                 // low -> high
      : chordNotes.slice().reverse();      // high -> low

    // Strum spread by "strings"
    const spread = p.strumSpreadSec * lerp(1.0, 0.85, ev.kind === "arp" ? 0.6 : 0.0);

    // Envelope shaping: Singer Mode softer transient (slower attack, slightly shorter release)
    const atk = lerp(0.004, 0.010, p.singer) * lerp(1.0, 1.2, (1 - vel));
    const rel = lerp(0.22, 0.14, p.singer);
    const dur = clamp(ev.durSec * lerp(1.0, 0.85, p.singer), 0.18, 1.2);

    // Arp: focus bass + top note instead of full chord in Singer Mode
    if (ev.kind === "arp") {
      if (p.singer > 0.55) {
        // keep 2 notes: lowest + one upper tone
        const low = chordNotes[0];
        const high = chordNotes[chordNotes.length - 1];
        playNote(low, timeSec, dur * 0.95, vel * 0.95, atk, rel);
        playNote(high, timeSec + spread * 1.3, dur * 0.85, vel * 0.75, atk, rel);
        return;
      }
      // normal arp: walk through 3 notes
      const pick = [order[0], order[Math.floor(order.length/2)], order[order.length - 1]].filter(n => n != null);
      pick.forEach((n, i) => playNote(n, timeSec + i * spread * 1.2, dur * 0.9, vel * (i === 0 ? 1.0 : 0.8), atk, rel));
      return;
    }

    // Strum: full-ish chord; Singer Mode may drop an inner note for space
    let notes = order;
    if (p.singer > 0.65 && notes.length >= 4) {
      // remove one inner tone (reduce masking)
      const mid = Math.floor(notes.length / 2);
      notes = notes.filter((_, idx) => idx !== mid);
    }

    notes.forEach((midi, i) => {
      const t = timeSec + i * spread;
      const v = vel * (1 - (i * 0.04)); // slightly taper
      playNote(midi, t, dur, v, atk, rel);
    });
  }

  function playNote(midi, timeSec, durSec, gain01, attackSec, releaseSec) {
    if (!instrument) return;

    // Prevent too-hot
    const g = clamp(gain01, 0.03, 1.0);

    // In Singer Mode, reduce “pick glare” by shrinking gain on very high notes
    const singer = norm01FromSlider(ui.singer);
    const hiAtten = midi >= 76 ? lerp(1.0, 0.78, singer) : 1.0;
    const finalGain = g * hiAtten;

    instrument.play(midi, timeSec, {
      gain: finalGain,
      duration: durSec,
      attack: attackSec,
      release: releaseSec
    });
  }

  // ---------- Mic ducking ----------
  async function setMicDucking(on) {
    if (!ac) ensureAudioContext();

    if (!on) {
      stopMicLoop();
      if (out && out.duckGain) out.duckGain.gain.setTargetAtTime(1.0, ac.currentTime, 0.03);
      return;
    }

    // request mic
    if (!navigator.mediaDevices?.getUserMedia) {
      log("Mic ducking: getUserMedia không hỗ trợ trên trình duyệt này.");
      ui.duck.value = "off";
      return;
    }

    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: false
        }
      });
      mic.stream = stream;
      mic.source = ac.createMediaStreamSource(stream);

      mic.analyser = ac.createAnalyser();
      mic.analyser.fftSize = 1024;
      mic.analyser.smoothingTimeConstant = 0.86;
      mic.data = new Uint8Array(mic.analyser.fftSize);

      mic.source.connect(mic.analyser);

      mic.env = 0;
      mic.lastT = nowMs();
      mic.raf = requestAnimationFrame(micLoop);

      log("Mic ducking: ON.");
    } catch (e) {
      log("Mic ducking: không lấy được micro (bị từ chối hoặc lỗi quyền).");
      ui.duck.value = "off";
    }
  }

  function stopMicLoop() {
    if (mic.raf) cancelAnimationFrame(mic.raf);
    mic.raf = 0;

    if (mic.stream) {
      for (const tr of mic.stream.getTracks()) tr.stop();
    }
    mic.stream = null;
    mic.source = null;
    mic.analyser = null;
    mic.data = null;
    mic.env = 0;
  }

  function micLoop() {
    if (!mic.analyser || !mic.data || !ac) return;

    mic.analyser.getByteTimeDomainData(mic.data);

    // RMS estimate
    let sumSq = 0;
    for (let i = 0; i < mic.data.length; i++) {
      const x = (mic.data[i] - 128) / 128;
      sumSq += x * x;
    }
    const rms = Math.sqrt(sumSq / mic.data.length); // ~0..1
    const rmsDb = 20 * Math.log10(Math.max(1e-6, rms));

    // Envelope follower (attack/release)
    const tNow = nowMs();
    const dt = Math.max(0.001, (tNow - mic.lastT) / 1000);
    mic.lastT = tNow;

    // “signal present” when > -45dBFS-ish (tune as needed)
    const target = rmsDb > -45 ? clamp((rmsDb + 45) / 25, 0, 1) : 0; // 0..1
    const atk = 1 - Math.exp(-dt / 0.020);
    const rel = 1 - Math.exp(-dt / 0.140);
    mic.env += (target - mic.env) * (target > mic.env ? atk : rel);

    // Compute duck gain
    const singer = norm01FromSlider(ui.singer);
    const antiPull = norm01FromSlider(ui.antipull);
    const strength = lerp(0.25, 0.55, singer) * lerp(0.6, 1.0, antiPull);

    // max reduction: up to ~ -6dB (0.5) but usually less
    const reduction = 1 - (mic.env * strength * 0.65);
    const g = clamp(reduction, 0.55, 1.0);

    out.duckGain.gain.setTargetAtTime(g, ac.currentTime, 0.015);

    mic.raf = requestAnimationFrame(micLoop);
  }

  // ---------- Buttons / events ----------
  ui.btnStart.addEventListener("click", async () => {
    ui.btnStart.disabled = true;
    try {
      await unlockAudio();
      await loadInstrument();
      if (ui.duck.value === "on") await setMicDucking(true);
      log("Ready. Press Play.");
    } catch (e) {
      console.error(e);
      log("Load error. Check console / network.");
      ui.btnStart.disabled = false;
    }
  });

  ui.btnPlay.addEventListener("click", async () => {
    try {
      await unlockAudio();
      startTransport();
    } catch (e) {
      console.error(e);
      log("Play error. Check console.");
    }
  });

  ui.btnStop.addEventListener("click", () => stopTransport());

  ui.btnTest.addEventListener("click", async () => {
    await unlockAudio();
    const p = computePolicy();
    applyMixPolicy(p);

    const chordSym = (parseProgression(ui.prog.value)[0] || "C");
    const pcs = chordToPitchClasses(chordSym) || chordToPitchClasses("C");

    const t = ac.currentTime + 0.06;
    scheduleEvent(chordSym, pcs, t, { kind:"strum", dir:"down", vel: 0.92, durSec: 0.75, gate: 1.0 }, p, 0.9);
    log(`Test strum: ${chordSym}`);
  });

  ui.outGain.addEventListener("input", () => {
    if (!ac) return;
    setOutputGain(norm01FromSlider(ui.outGain));
  });

  ui.duck.addEventListener("change", async () => {
    if (ui.duck.value === "on") {
      await unlockAudio();
      await setMicDucking(true);
    } else {
      await setMicDucking(false);
      log("Mic ducking: OFF.");
    }
  });

  // Auto-stop on page hide to avoid “stuck audio” states on iOS
  document.addEventListener("visibilitychange", () => {
    if (document.hidden && transport.isPlaying) stopTransport();
  });

})();
</script>
</body>
</html>